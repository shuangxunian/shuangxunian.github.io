<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta charset="UTF-8">
  <meta 
    name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta 
    http-equiv="X-UA-Compatible" 
    content="ie=edge">
  <meta 
    name="theme-color" 
    content="#fff" 
    id="theme-color">
  <meta 
    name="description" 
    content="记录个人成长与生活，前端，算法，nlp">
  <link 
    rel="icon" 
    href="https://q2.qlogo.cn/headimg_dl?dst_uin=2749909223&amp;spec=5">
  <title>图论</title>
  
    
      <meta 
        property="og:title" 
        content="图论">
    
    
      <meta 
        property="og:url" 
        content="http://example.com/2022/09/30/graphTheory/index.html">
    
    
      <meta 
        property="og:img" 
        content="https://img-blog.csdnimg.cn/20181119190833309.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hamlubGVpMTIx,size_1,color_FFFFFF,t_70">
    
    
      <meta 
        property="og:img" 
        content="常用的图论题&amp;思路">
    
    
      <meta 
        property="og:type" 
        content="article">
      <meta 
        property="og:article:published_time" 
        content="2022-09-30">
      <meta 
        property="og:article:modified_time" 
        content="2022-09-30">
      <meta 
        property="og:article:author" 
        content="霜序廿">
      
        
          <meta 
            property="og:article:tag" 
            content="图论">
        
      
    
  
  
  <link rel="preload" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css" as="style" >
  <link rel="preload" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css" as="style" >
  <link rel="preload" href="/css/main.css" as="style" >
  
  <link rel="modulepreload" href="//instant.page/5.1.0">
  
  <link rel="stylesheet" href="/css/main.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css">
  
  
  
    <link rel="stylesheet" href="/js/lib/lightbox/baguetteBox.min.css">
  
  <script>
    function loadScript(url, cb) {
      var script = document.createElement('script');
      script.src = url;
      if (cb) script.onload = cb;
      script.async = true;
      document.body.appendChild(script);
    }
    function loadCSS(href, data, attr) {
      var sheet = document.createElement('link');
      sheet.ref = 'stylesheet';
      sheet.href = href;
      sheet.dataset[data] = attr;
      document.head.appendChild(sheet);
    }
    function changeCSS(cssFile, data, attr) {
      var oldlink = document.querySelector(data);
      var newlink = document.createElement("link");
      newlink.setAttribute("rel", "stylesheet");
      newlink.setAttribute("href", cssFile);
      newlink.dataset.prism = attr;
      document.head.replaceChild(newlink, oldlink);
    }
  </script>
  
    
  
  <script>
    // control reverse button
    var reverseDarkList = {
      dark: 'light',
      light: 'dark'
    };
    var themeColor = {
      dark: '#1c1c1e',
      light: '#fff'
    }
    // get the data of css prefers-color-scheme
    var getCssMediaQuery = function() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };
    // reverse current darkmode setting function
    var reverseDarkModeSetting = function() {
      var setting = localStorage.getItem('user-color-scheme');
      if(reverseDarkList[setting]) {
        setting = reverseDarkList[setting];
      } else if(setting === null) {
        setting = reverseDarkList[getCssMediaQuery()];
      } else {
        return;
      }
      localStorage.setItem('user-color-scheme', setting);
      return setting;
    };
    // apply current darkmode setting
  </script>
  
    <script>
      var setDarkmode = function(mode) {
      var setting = mode || localStorage.getItem('user-color-scheme');
      if(setting === getCssMediaQuery()) {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[setting];
        document.getElementById('theme-color').dataset.mode = setting;
      } else if(reverseDarkList[setting]) {
        document.documentElement.setAttribute('data-user-color-scheme', setting);
        document.getElementById('theme-color').content = themeColor[setting];
        document.getElementById('theme-color').dataset.mode = setting;
      } else {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[getCssMediaQuery()];
        document.getElementById('theme-color').dataset.mode = getCssMediaQuery();
      }
    };
    setDarkmode();
    </script>
  
  
  
    <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.js" as="script">
    <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.css" as="style" >
  
  
    <link rel="preload" href="/js/lib/lozad.min.js" as="script">
  
  
  
  
  
  
<meta name="generator" content="Hexo 6.3.0"></head>

  <body>
    <div class="wrapper">
       
      <nav class="navbar">
  <div class="navbar-logo">
    <a class="navbar-logo-main" href="/">
      
        <img 
          class="navbar-logo-img"
          width="32"
          height="32"
          src="https://q2.qlogo.cn/headimg_dl?dst_uin=2749909223&spec=5" 
          alt="blog logo">
      
      <span class="navbar-logo-dsc">霜序廿的个人网站</span>
      </a>
  </div>
  <div class="navbar-menu">
    
      <a 
        href="/" 
        class="navbar-menu-item">
        
          首页
        
      </a>
    
      <a 
        href="/archives" 
        class="navbar-menu-item">
        
          归档
        
      </a>
    
      <a 
        href="/tags" 
        class="navbar-menu-item">
        
          标签
        
      </a>
    
      <a 
        href="/categories" 
        class="navbar-menu-item">
        
          分类
        
      </a>
    
      <a 
        href="/about" 
        class="navbar-menu-item">
        
          关于
        
      </a>
    
      <a 
        href="/links" 
        class="navbar-menu-item">
        
          友链
        
      </a>
    
    <button 
      class="navbar-menu-item darknavbar navbar-menu-btn" 
      aria-label="Toggle dark mode"
      id="dark">
      <i class="iconfont icon-weather"></i>
    </button>
    <button 
      class="navbar-menu-item searchnavbar navbar-menu-btn" 
      aria-label="Toggle search"
      id="search">
      <!-- <i 
        class="iconfont icon-search" 
        style="font-size: 1.2rem; font-weight: 400;">
      </i> -->
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img"
        class="iconify iconify--ion" width="28" height="28" preserveAspectRatio="xMidYMid meet" viewBox="0 0 512 512">
        <path fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="28"
          d="M256 80a176 176 0 1 0 176 176A176 176 0 0 0 256 80Z"></path>
        <path fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="28"
          d="M232 160a72 72 0 1 0 72 72a72 72 0 0 0-72-72Z"></path>
        <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="28"
          d="M283.64 283.64L336 336"></path>
      </svg>
    </button>
  </div>
</nav> 
      
      <div 
        id="local-search" 
        style="display: none">
        <input
          class="navbar-menu-item"
          id="search-input"
          placeholder="请输入搜索内容..." />
        <div id="search-content"></div>
      </div>
      
      <div class="section-wrap">
        <div class="container">
          <div class="columns">
            <aside class="left-column">
              
              <div class="card card-author">
                
  <img 
    src="https://q2.qlogo.cn/headimg_dl?dst_uin=2749909223&spec=5" 
    class="author-img"
    width="88"
    height="88"
    alt="author avatar">

<p class="author-name">霜序廿</p>
<p class="author-description">一个爱算法的小前端</p>
<div class="author-message">
  <a 
    class="author-posts-count" 
    href="/archives">
    <span>252</span>
    <span>文章</span>
  </a>
  <a 
    class="author-categories-count" 
    href="/categories">
    <span>7</span>
    <span>分类</span>
  </a>
  <a 
    class="author-tags-count" 
    href="/tags">
    <span>52</span>
    <span>标签</span>
  </a>
</div>

  <div class="author-card-society">
    
      <div class="author-card-society-icon">
        <a target="_blank" rel="noopener" href="https://github.com/shuangxunian">
          <i class="iconfont icon-github society-icon"></i>
        </a>
      </div>
    
      <div class="author-card-society-icon">
        <a target="_blank" rel="noopener" href="https://space.bilibili.com/391117803">
          <i class="iconfont icon-bilibili society-icon"></i>
        </a>
      </div>
    
  </div>

              </div>
               <div class="sticky-tablet">
  
  
    <article class="display-when-two-columns spacer">
      <div class="card card-content toc-card">
        <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>目录
</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E8%AE%BA"><span class="toc-text">图论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5"><span class="toc-text">常见概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%B5%81%E5%B8%B8%E7%94%A8%E6%A6%82%E5%BF%B5"><span class="toc-text">网络流常用概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%A6%E5%9B%BE%E5%B8%B8%E7%94%A8%E6%A6%82%E5%BF%B5"><span class="toc-text">弦图常用概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%BB%93%E8%AE%BA"><span class="toc-text">常见结论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%A6%E5%9B%BE"><span class="toc-text">弦图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%8A%BF%E7%AE%97%E6%B3%95%E6%B1%82%E6%B6%88%E9%99%A4%E5%BA%8F%E5%88%97%E5%B9%B6%E5%88%A4%E5%AE%9A%E5%BC%A6%E5%9B%BE"><span class="toc-text">最大势算法求消除序列并判定弦图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%85%83%E7%8E%AF"><span class="toc-text">三元环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-text">步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-text">最短路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dijkstra%E5%A0%86%E4%BC%98%E5%8C%96"><span class="toc-text">Dijkstra堆优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SPFA"><span class="toc-text">SPFA</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#BFS%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%89"><span class="toc-text">BFS实现（求最短路）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DFS%E4%BC%98%E5%8C%96%EF%BC%88%E8%B4%9F%E7%8E%AF%E6%A3%80%E6%B5%8B%EF%BC%89"><span class="toc-text">DFS优化（负环检测）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Floyd"><span class="toc-text">Floyd</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%9B%A2"><span class="toc-text">最大团</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%9B%A2%E5%A4%A7%E5%B0%8F"><span class="toc-text">最大团大小</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F"><span class="toc-text">差分约束</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95"><span class="toc-text">解法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-MST"><span class="toc-text">最小生成树(MST)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Prim%E7%AE%97%E6%B3%95"><span class="toc-text">Prim算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kruskal"><span class="toc-text">Kruskal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Boruvka"><span class="toc-text">Boruvka</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-text">流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E4%BE%8B%E9%A2%98"><span class="toc-text">典型例题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">次小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E6%B4%9B%E8%B0%B7P4180"><span class="toc-text">严格次小生成树(洛谷P4180)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88MDST%EF%BC%8C%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE%EF%BC%89"><span class="toc-text">有向图最小生成树（MDST，最小树形图）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%B1%E5%88%98%E7%AE%97%E6%B3%95%EF%BC%88Edmonds-%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-text">朱刘算法（Edmonds 算法）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B-1"><span class="toc-text">流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-text">模板</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%A0%91"><span class="toc-text">虚树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1"><span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%9B%BE%E6%90%9C%E7%B4%A2"><span class="toc-text">补图搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%9B%BE%E8%BF%9E%E9%80%9A%E5%9D%97-0-1-MST"><span class="toc-text">补图连通块 0-1 MST </span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="toc-text">强连通分量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Tarjan"><span class="toc-text">Tarjan</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Tarjan%E7%BC%A9%E7%82%B9-DAG-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8Fdp"><span class="toc-text">Tarjan缩点+DAG 拓扑排序dp</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Tarjan%E6%97%A0%E5%90%91%E5%9B%BE%E6%B1%82%E5%89%B2%E7%82%B9"><span class="toc-text">Tarjan无向图求割点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E6%B1%82%E6%A1%A5"><span class="toc-text">无向图求桥</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-SAT%E9%97%AE%E9%A2%98"><span class="toc-text">2-SAT问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B-2"><span class="toc-text">流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BB%BA%E5%9B%BE%E6%96%B9%E5%BC%8F"><span class="toc-text">建图方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-LCA"><span class="toc-text">最近公共祖先(LCA)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%8D%E5%A2%9E"><span class="toc-text">倍增</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-text">应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86"><span class="toc-text">树上差分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8"><span class="toc-text">性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%82%B9%E7%9A%84%E5%B7%AE%E5%88%86"><span class="toc-text">点的差分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C"><span class="toc-text">操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9"><span class="toc-text">修改</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E7%9A%84%E5%B7%AE%E5%88%86"><span class="toc-text">边的差分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C-1"><span class="toc-text">操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9-1"><span class="toc-text">修改</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2"><span class="toc-text">查询</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86"><span class="toc-text">树链剖分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF"><span class="toc-text">通用模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P3384-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86"><span class="toc-text">P3384 树链剖分 </span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E5%88%86%E6%B2%BB"><span class="toc-text">点分治</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83"><span class="toc-text">树的重心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B-3"><span class="toc-text">流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6%EF%BC%88DSU-on-tree%EF%BC%89"><span class="toc-text">树上启发式合并（DSU on tree）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B-4"><span class="toc-text">流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="toc-text">二分图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E4%BA%8C%E5%88%86%E5%9B%BE%E7%BB%93%E8%AE%BA"><span class="toc-text">常见二分图结论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E4%BB%BB%E6%84%8F%E5%9B%BE%E7%9A%84%E7%BB%93%E8%AE%BA"><span class="toc-text">适用任意图的结论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E5%88%A4%E5%AE%9A%EF%BC%88%E9%BB%91%E7%99%BD%E6%9F%93%E8%89%B2%E6%B3%95%EF%BC%89"><span class="toc-text">二分图判定（黑白染色法）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95"><span class="toc-text">匈牙利算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-text">邻接表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KM%E7%AE%97%E6%B3%95"><span class="toc-text">KM算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#BFS%EF%BC%8C%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A8%B3%E7%9A%84%E4%B8%80%E6%89%B9"><span class="toc-text">BFS，复杂度稳的一批</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A6%E5%8F%B3%E6%95%B0%E7%9B%AE%E4%B8%8D%E7%AD%89%E7%9A%84%E6%A8%A1%E6%9D%BF"><span class="toc-text">左右数目不等的模板</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CSL%E7%9A%84%E5%86%99%E6%B3%95"><span class="toc-text">CSL的写法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%B5%81"><span class="toc-text">网络流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E9%83%A8%E5%88%86"><span class="toc-text">模板部分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#dinic"><span class="toc-text">dinic</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dijkstra%E8%B4%B9%E7%94%A8%E6%B5%81"><span class="toc-text">dijkstra费用流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%B5%81"><span class="toc-text">最大流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%AA%E7%A9%BA%E9%A3%9E%E8%A1%8C%E8%AE%A1%E5%88%92%E9%97%AE%E9%A2%98%EF%BC%88%E6%9C%80%E5%B0%8F%E5%89%B2-%E6%94%B6%E7%9B%8A%E6%9C%80%E5%A4%A7%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-text">太空飞行计划问题（最小割,收益最大问题）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98-%E6%9C%80%E5%A4%A7%E6%B5%81-%E6%9C%80%E5%B0%8F%E4%B8%8D%E7%9B%B8%E4%BA%A4%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E6%A8%A1%E5%9E%8B-%E8%A6%81%E6%B1%82%E8%B7%AF%E5%BE%84%E6%95%B0%E6%9C%80%E5%B0%91-%E8%B7%AF%E5%BE%84%E8%BE%93%E5%87%BA"><span class="toc-text">最小路径覆盖问题(最大流,最小不相交路径覆盖模型,要求路径数最少,路径输出)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#P2774-%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0%E9%97%AE%E9%A2%98-%E6%9C%80%E5%A4%A7%E6%B5%81%EF%BC%8C%E6%9C%80%E5%B0%8F%E5%89%B2"><span class="toc-text">P2774 方格取数问题(最大流，最小割)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%B9%E7%94%A8%E6%B5%81"><span class="toc-text">费用流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#P4012-%E6%B7%B1%E6%B5%B7%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%97%AE%E9%A2%98%EF%BC%88%E7%89%A9%E5%93%81%E5%9C%A8%E7%BD%91%E6%A0%BC%E4%B8%8A%EF%BC%89"><span class="toc-text">P4012 深海机器人问题（物品在网格上）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#P3356-%E7%81%AB%E6%98%9F%E6%8E%A2%E9%99%A9%E9%97%AE%E9%A2%98%EF%BC%88%E7%89%A9%E5%93%81%E5%9C%A8%E4%BA%A4%E5%8F%89%E7%82%B9%E4%B8%8A%EF%BC%89"><span class="toc-text">P3356 火星探险问题（物品在交叉点上）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#P2604-%E6%89%A9%E5%AE%B9%E8%B4%B9%E7%94%A8%E9%97%AE%E9%A2%98"><span class="toc-text">P2604 扩容费用问题 </span></a></li></ol></li></ol></li></ol></li></ol>
      </div>
    </article>
  
  
  <article class="card card-content categories-widget">
    <div class="categories-card">
  <div class="categories-header">
    <i 
      class="iconfont icon-fenlei" 
      style="padding-right: 2px;">
    </i>分类
  </div>
  <div class="categories-list">
    
      <a href="/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/">
        <div class="categories-list-item">
          技术文章
          <span class="categories-list-item-badge">216</span>
        </div>
      </a>
    
      <a href="/categories/%E6%97%85%E6%B8%B8/">
        <div class="categories-list-item">
          旅游
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/%E5%85%B6%E4%BB%96/">
        <div class="categories-list-item">
          其他
          <span class="categories-list-item-badge">12</span>
        </div>
      </a>
    
      <a href="/categories/%E6%B8%B8%E6%88%8F/">
        <div class="categories-list-item">
          游戏
          <span class="categories-list-item-badge">7</span>
        </div>
      </a>
    
      <a href="/categories/%E7%AE%97%E6%B3%95/">
        <div class="categories-list-item">
          算法
          <span class="categories-list-item-badge">7</span>
        </div>
      </a>
    
      <a href="/categories/%E8%80%83%E8%AF%95/">
        <div class="categories-list-item">
          考试
          <span class="categories-list-item-badge">8</span>
        </div>
      </a>
    
      <a href="/categories/%E9%98%85%E8%AF%BB/">
        <div class="categories-list-item">
          阅读
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
  </div>
</div>
  </article>
  
  <article class="card card-content tags-widget">
    <div class="tags-card">
  <div class="tags-header">
    <i 
      class="iconfont icon-biaoqian" 
      style="padding-right: 2px;">
    </i>热门标签
  </div>
  <div class="tags-list">
    
      <a 
        href="/tags/js/" 
        title="js">
        <div class="tags-list-item">js</div>
      </a>
    
      <a 
        href="/tags/vue/" 
        title="vue">
        <div class="tags-list-item">vue</div>
      </a>
    
      <a 
        href="/tags/%E9%9D%A2%E8%AF%95/" 
        title="面试">
        <div class="tags-list-item">面试</div>
      </a>
    
      <a 
        href="/tags/css/" 
        title="css">
        <div class="tags-list-item">css</div>
      </a>
    
      <a 
        href="/tags/%E7%BD%91%E7%BB%9C/" 
        title="网络">
        <div class="tags-list-item">网络</div>
      </a>
    
      <a 
        href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" 
        title="浏览器">
        <div class="tags-list-item">浏览器</div>
      </a>
    
      <a 
        href="/tags/%E5%85%B6%E4%BB%96/" 
        title="其他">
        <div class="tags-list-item">其他</div>
      </a>
    
      <a 
        href="/tags/%E7%AE%97%E6%B3%95/" 
        title="算法">
        <div class="tags-list-item">算法</div>
      </a>
    
      <a 
        href="/tags/html/" 
        title="html">
        <div class="tags-list-item">html</div>
      </a>
    
      <a 
        href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" 
        title="操作系统">
        <div class="tags-list-item">操作系统</div>
      </a>
    
      <a 
        href="/tags/%E8%80%83%E8%AF%95/" 
        title="考试">
        <div class="tags-list-item">考试</div>
      </a>
    
      <a 
        href="/tags/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/" 
        title="网络原理">
        <div class="tags-list-item">网络原理</div>
      </a>
    
      <a 
        href="/tags/%E5%8E%9F%E7%A5%9E/" 
        title="原神">
        <div class="tags-list-item">原神</div>
      </a>
    
      <a 
        href="/tags/DOM/" 
        title="DOM">
        <div class="tags-list-item">DOM</div>
      </a>
    
      <a 
        href="/tags/%E8%BD%AE%E5%AD%90/" 
        title="轮子">
        <div class="tags-list-item">轮子</div>
      </a>
    
      <a 
        href="/tags/debug/" 
        title="debug">
        <div class="tags-list-item">debug</div>
      </a>
    
  </div>
</div>
  </article>
  
  
</div>
            </aside>
            <main class="main-column">
              
  <div class="image-wrapper">
    <img 
      src="https://img-blog.csdnimg.cn/20181119190833309.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hamlubGVpMTIx,size_1,color_FFFFFF,t_70" 
      data-src="https://img-blog.csdnimg.cn/20181119190833309.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hamlubGVpMTIx,size_1,color_FFFFFF,t_70"
      srcset="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20viewBox=&#39;0%200%20300%20300&#39;%3E%3C/svg%3E"
      class="image lozad"
      alt="图论 thumbnail">
  </div>

<article class="card card-content">
  <header>
    <h1 class="post-title">
      图论
    </h1>
  </header>
  <div class="post-meta post-show-meta">
    <a href="https://github.com/shuangxunian/shuangxunian.github.io/edit/server/source/_posts/graphTheory.md" target="_blank">编辑原文</a>
  </div>
  <div class="post-meta post-show-meta">
    <time datetime="2022-09-30T00:00:00.000Z">
      <i 
        class="iconfont icon-calendar" 
        style="margin-right: 2px;">
      </i>
      <span>2022-09-30</span>
    </time>
    
      <span class="dot"></span>
      
        <a 
          href="/categories/%E7%AE%97%E6%B3%95/" 
          class="post-meta-link">
          算法
        </a>
      
    
    
      <span class="dot"></span>
      <span>16.9k 字</span>
    
  </div>
  
    <div 
      class="post-meta post-show-meta" 
      style="margin-top: -10px;">
      <div style="display: flex; align-items: center;">
        <i 
          class="iconfont icon-biaoqian" 
          style="margin-right: 2px; font-size: 1.15rem;">
        </i>
        
          
          <a 
            href="/tags/%E5%9B%BE%E8%AE%BA/" 
            class="post-meta-link">
            图论
          </a>
        
      </div>
    </div>
  
  </header>
  <div 
    id="section" 
    class="post-content">
    <h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><p>作者 Overstars</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Miaplacidus">https://blog.csdn.net/Miaplacidus</a></p>
<h3 id="常见概念"><a href="#常见概念" class="headerlink" title="常见概念"></a>常见概念</h3><ul>
<li>简单图：不含有平行边和环的图。</li>
<li>多重图：含有平行边（同向）的图。</li>
<li>完全图：每一对节点之间都有边的简单图，$n$个节点无向完全图记为$K_n$。</li>
<li>平面图：能将所有点和边画在平面上，且边与边不相交的<strong>无向</strong>图。</li>
<li>补图：由$G$中<strong>所有节点</strong>和所有能使$G$成为完全图的<strong>添加边</strong>组成的图。</li>
<li>生成子图(Spanning Subgraph)：含有原图$G$中所有结点的子图。</li>
<li>图同构的<strong>必要条件</strong>：<ol>
<li>节点数相同。</li>
<li>边数相同。</li>
<li>度数相同的结点数相同。</li>
</ol>
</li>
</ul>
<h4 id="网络流常用概念"><a href="#网络流常用概念" class="headerlink" title="网络流常用概念"></a>网络流常用概念</h4><ul>
<li>连通图：只有一个连通分支（极大连通子图）的图。</li>
<li>割点：无向连通图中一个顶点$v$,，若删除它以及关联的边后，得到的新图至少包含两个连通分支。</li>
<li>桥：无向连通图中的一条边$e$，删除它得到的新图包含两个连通分量。</li>
<li>团(Clique)：原图$G$的一个<strong>完全</strong>子图。</li>
<li>极大团(Maximal Clique)：不是其它团的子图的团。</li>
<li>最大团(Maximum Clique)：顶点最多的极大团。</li>
<li>诱导子图(Induced Subgraph)：所有节点在原图$G$上连接的边都被包含在内的子图。</li>
<li>独立集：在图上选出一些节点，这些<strong>节点间两两无边</strong>的点集。</li>
<li>路径覆盖：在图中找一些路径，这些路径覆盖图中所有的顶点，每个顶点都只与一条路径相关联。</li>
<li>最小染色数：用最少的颜色个数给点染色且任意两点相邻点颜色不同，最少的颜色个数。</li>
</ul>
<h4 id="弦图常用概念"><a href="#弦图常用概念" class="headerlink" title="弦图常用概念"></a>弦图常用概念</h4><ul>
<li>弦：连接环上两个不相邻节点的边。</li>
<li>弦图：图上任意一个点数大于三的环都至少存在一条弦的无向图。</li>
<li>单纯点：节点$v$与相邻节点的诱导子图是一个团。</li>
<li>完美消除序列：有$n$个点的排列$v_1,v_2,\dots,v_n$，该排列满足$v_i$在${v_i,v_{i+1},\dots,v_n}$的诱导子图中是一个单纯点。</li>
<li><strong>一个无向图是弦图当且仅当它有一个完美消除序列</strong></li>
</ul>
<h3 id="常见结论"><a href="#常见结论" class="headerlink" title="常见结论"></a>常见结论</h3><ul>
<li>每个图中节点<strong>度数和</strong>等于边数的二倍，$\sum\limits_{v\in V} deg(v)&#x3D;2\left| E \right|$。</li>
<li>任何图中度数为奇数的节点必定有偶数个。</li>
<li>完全图$K_n$的边数$&#x3D;\frac{n(n-1)}{2}$</li>
<li>最大团中顶点数量 &#x3D; 补图的最大独立集中顶点数量</li>
<li>最大团数 ≤ 最小染色数，最大独立集 ≤ 最小团覆盖</li>
<li>弦图中：最大团数 &#x3D; 最小染色数，最大独立集 &#x3D; 最小团覆盖</li>
<li>平面图边数$m\le 3n-6$。</li>
<li>git config –global core.autocrlf false和git config –global core.safecrlf true还有git init</li>
</ul>
<h3 id="弦图"><a href="#弦图" class="headerlink" title="弦图"></a>弦图</h3><h4 id="最大势算法求消除序列并判定弦图"><a href="#最大势算法求消除序列并判定弦图" class="headerlink" title="最大势算法求消除序列并判定弦图"></a>最大势算法求消除序列并判定弦图</h4><p>判断一个消除序列是否为完美消除序列：从后向前枚举序列中的点$v_i$，设序列中在$v_i$后且与$v_i$相邻的点集<strong>依次</strong>为${v_{j1},v_{j2},\dots,v_{jk}}$，判断$v_j1$是否与${v_{j2},\dots,v_{jk}}$相邻即可。</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1005</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><br>&#123;<br>	<span class="hljs-type">int</span> v,nex;<br>	<span class="hljs-built_in">edge</span>(<span class="hljs-type">int</span> v=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> n=<span class="hljs-number">-1</span>):<br>		<span class="hljs-built_in">v</span>(v),<span class="hljs-built_in">nex</span>(n)&#123;&#125;<br>&#125; e[maxn*maxn];<br><span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>,head[maxn];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>	e[++cnt].v=v;<br>	e[cnt].nex=head[u];<br>	head[u]=cnt;<br>&#125;<br><span class="hljs-type">int</span> label[maxn],id[maxn],order[maxn];<span class="hljs-comment">//id[i]表示节点i在序列中的编号</span><br><span class="hljs-type">bool</span> vis[maxn];<span class="hljs-comment">//order[i]为完美消除序列第i个节点,label[x]表示x点与多少个已标号节点相邻</span><br>vector&lt;<span class="hljs-type">int</span>&gt; vec[maxn];<span class="hljs-comment">//vec[x]存储*与x个已标号节点相邻*的节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mcs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><span class="hljs-comment">//节点数量</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//复杂度O(n+m)</span><br>	<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>	<span class="hljs-built_in">memset</span>(label,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(label));<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>		vec[<span class="hljs-number">0</span>].<span class="hljs-built_in">push_back</span>(i);<br>	<span class="hljs-type">int</span> maxx=<span class="hljs-number">0</span>,now=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>	&#123;<span class="hljs-comment">//从前往后,每轮必定会找出一个</span><br>		<span class="hljs-type">bool</span> flag=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">while</span>(!flag)<br>		&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=vec[maxx].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--)<br>			&#123;<span class="hljs-comment">//从后往前找</span><br>				<span class="hljs-keyword">if</span>(vis[vec[maxx][j]])<span class="hljs-comment">//该节点已经标记过</span><br>					vec[maxx].<span class="hljs-built_in">pop_back</span>();<br>				<span class="hljs-keyword">else</span>&#123;<br>					flag=<span class="hljs-number">1</span>;<span class="hljs-comment">//找到个未访问的节点</span><br>					now=vec[maxx][j];<br>					<span class="hljs-keyword">break</span>;<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">if</span>(!flag)<br>				maxx--;<br>		&#125;<br>		vis[now]=<span class="hljs-number">1</span>;<span class="hljs-comment">//</span><br>		order[n-i+<span class="hljs-number">1</span>]=now;<br>		id[now]=n-i+<span class="hljs-number">1</span>;<span class="hljs-comment">//节点x在序列中的位置</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=head[now];~j;j=e[j].nex)<br>		&#123;<span class="hljs-comment">//遍历与now节点相邻的节点</span><br>			<span class="hljs-type">int</span> v=e[j].v;<br>			<span class="hljs-keyword">if</span>(!vis[v])<br>			&#123;<br>				label[v]++;<span class="hljs-comment">//v节点与已标号节点数++</span><br>				vec[label[v]].<span class="hljs-built_in">push_back</span>(v);<br>				maxx=<span class="hljs-built_in">max</span>(maxx,label[v]);<span class="hljs-comment">//找出最大的那个节点</span><br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-type">int</span> bucket[maxn];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isperfect</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//复杂度O(n+m)</span><br>	<span class="hljs-built_in">mcs</span>(n);<span class="hljs-comment">//计算消除序列并判断是否为完美消除序列</span><br>	<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<span class="hljs-comment">//判断序列中的点v_i是否与其后所有点相接</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;<span class="hljs-number">0</span>;i--)<span class="hljs-comment">//序列从后向前</span><br>	&#123;<br>		<span class="hljs-type">int</span> tot=<span class="hljs-number">0</span>,ret=<span class="hljs-number">1</span>;<span class="hljs-comment">//每轮桶清空</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=head[order[i]];~j;j=e[j].nex)<br>			<span class="hljs-keyword">if</span>(id[e[j].v]&gt;i)<span class="hljs-comment">//排在序列编号x后面与x相邻的点集记为:N(x)</span><br>				vis[bucket[++tot]=e[j].v]=<span class="hljs-number">1</span>;<span class="hljs-comment">//序列中x后且与x邻接点标记并放入桶中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=head[bucket[<span class="hljs-number">1</span>]];~j;j=e[j].nex)<span class="hljs-comment">//buc[1]的id为N(x)中最小？</span><br>		&#123;<span class="hljs-comment">//bucket[1]=0...</span><br>			<span class="hljs-type">int</span> v=e[j].v;<br>			<span class="hljs-keyword">if</span>(v!=bucket[<span class="hljs-number">1</span>]&amp;&amp;vis[v])<br>			&#123;<span class="hljs-comment">//判断N(x)中排在最前面的点是否与N(x)其他点相邻</span><br>				ret++;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=tot;j++)<br>			vis[bucket[j]]=<span class="hljs-number">0</span>;<span class="hljs-comment">//防止每次memset超时</span><br>		<span class="hljs-keyword">if</span>(tot&amp;&amp;ret!=tot)<span class="hljs-comment">//不全部邻接</span><br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> n,m,u,v;<br>	<span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n&amp;&amp;m)<br>	&#123;<br>		<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>		<span class="hljs-built_in">memset</span>(order,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(order));<br>		cnt=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>			vec[i].<span class="hljs-built_in">clear</span>();<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>		&#123;<br>			cin&gt;&gt;u&gt;&gt;v;<br>			<span class="hljs-built_in">add</span>(u,v);<br>			<span class="hljs-built_in">add</span>(v,u);<br>		&#125;<br>		cout&lt;&lt;(<span class="hljs-built_in">isperfect</span>(n)?<span class="hljs-string">&quot;Perfect\n\n&quot;</span>:<span class="hljs-string">&quot;Imperfect\n\n&quot;</span>);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre>



<h3 id="三元环"><a href="#三元环" class="headerlink" title="三元环"></a>三元环</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>对原无向图进行定向，对任何一条边，从度数大的点连向度数小的点，如果度数相同，从编号小的点连向编号大的点。得到一个有向无环图。</li>
<li>枚举每一个节点$u$，将$u$所有相邻节点打上$u$的标记。再枚举$u$的相邻节点$v$，枚举$v$的相邻节点的相邻节点$w$，如果$w$上有被标记为$u$，则$(u,v,w)$就是一个三元环。</li>
</ol>
<p>统计图上三元环数量，复杂度$O(m\sqrt{m})$。</p>
<pre class="highlight"><code class="hljs cpp">vector G[maxn];<span class="hljs-comment">//新图</span><br><span class="hljs-type">int</span> vis[maxn],deg[maxn];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cycle3</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;e:edges)<br>    &#123;<span class="hljs-comment">//统计原无向图度数</span><br>        deg[e.u]++;<br>        deg[e.v]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;e:edges)<span class="hljs-comment">//建立新图</span><br>		<span class="hljs-keyword">if</span>(deg[e.u]&lt;deg[e.v]||(deg[e.u]==deg[e.v]&amp;&amp;e.u&lt;e.v))<br>			G[e.u].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">edge</span>(e.u,e.v));<br>		<span class="hljs-keyword">else</span><br>			G[e.v].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">edge</span>(e.v,e.u));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u=<span class="hljs-number">1</span>;u&lt;=n;u++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:G[u])<br>            vis[v]=u;<span class="hljs-comment">//相邻节点打上u的标记</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:G[u])<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w:G[v])<br>                <span class="hljs-keyword">if</span>(vis[w]==u)<br>                    ans++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre>

<h3 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h3><h4 id="Dijkstra堆优化"><a href="#Dijkstra堆优化" class="headerlink" title="Dijkstra堆优化"></a>Dijkstra堆优化</h4><p>复杂度$O(ElgE)$，稠密图中有时不如普通版优秀，但比SPFA快。</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">1050</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">qnode</span>&#123;<br>	<span class="hljs-type">int</span> v,c;<br>	<span class="hljs-built_in">qnode</span>(<span class="hljs-type">int</span> _v=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> _c=<span class="hljs-number">0</span>):<span class="hljs-built_in">v</span>(_v),<span class="hljs-built_in">c</span>(_c)&#123;&#125;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> qnode &amp;r)<span class="hljs-type">const</span>&#123;<br>		<span class="hljs-keyword">return</span> c&gt;r.c;<span class="hljs-comment">//重载运算符&lt;</span><br>	&#125;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> v,cost;<br>	<span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> _v=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> _cost=<span class="hljs-number">0</span>):<span class="hljs-built_in">v</span>(_v),<span class="hljs-built_in">cost</span>(_cost)&#123;&#125;<br>&#125;;<br>vector&lt;Edge&gt;E[MAXN];<span class="hljs-comment">//使用前必须清空0~n</span><br><span class="hljs-type">bool</span> vis[MAXN];<br><span class="hljs-type">int</span> dist[MAXN];<span class="hljs-comment">//到这个点的最近队员的</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> start)</span><span class="hljs-comment">//传入总数及起点</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//点的编号从 1 开始</span><br>	<span class="hljs-built_in">memset</span>(vis,<span class="hljs-literal">false</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>		dist[i]=inf;<br>	priority_queue&lt;qnode&gt;que;<br>	<span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>		que.<span class="hljs-built_in">pop</span>();<br>	dist[start]=<span class="hljs-number">0</span>;<br>	que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">qnode</span>(start,<span class="hljs-number">0</span>));<br>	<span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>	&#123;<br>		qnode now=que.<span class="hljs-built_in">top</span>();<br>		que.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-type">int</span> u=now.v;<br>		<span class="hljs-keyword">if</span>(vis[u])<br>			<span class="hljs-keyword">continue</span>;<br>		vis[u]=<span class="hljs-literal">true</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;E[u].<span class="hljs-built_in">size</span>();i++)<br>		&#123;<br>			<span class="hljs-type">int</span> v=E[u][i].v;<br>			<span class="hljs-type">int</span> cost=E[u][i].cost;<br>			<span class="hljs-keyword">if</span>(!vis[v]&amp;&amp;dist[v]&gt;dist[u]+cost)&#123;<br>				dist[v]=dist[u]+cost;<br>				que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">qnode</span>(v,dist[v]));<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)</span></span><br><span class="hljs-function"></span>&#123;<br>	E[u].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Edge</span>(v,w));<br>&#125;<br></code></pre>

<h4 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h4><p>最坏复杂度$O(VE)$，V为节点数，不适用于稠密图</p>
<p>检测负环：当存在一个点入队大于等于$V$次，则有负环</p>
<h5 id="BFS实现（求最短路）"><a href="#BFS实现（求最短路）" class="headerlink" title="BFS实现（求最短路）"></a>BFS实现（求最短路）</h5><pre class="highlight"><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">0x3f3f3f3f</span>,MAXN=<span class="hljs-number">5051</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br>	<span class="hljs-type">int</span> v,w,next;<br>&#125; e[MAXN];<br><span class="hljs-type">int</span> cnt,dist[MAXN],head[MAXN],num[MAXN];<br><span class="hljs-type">bool</span> vis[MAXN];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)</span><span class="hljs-comment">//链式前向星存图,无向则双向添加</span></span><br><span class="hljs-function"></span>&#123;<br>	e[cnt].v=v;<span class="hljs-comment">//边的结尾节点</span><br>	e[cnt].w=w;<br>	e[cnt].next=head[u];<span class="hljs-comment">//去找以u为起始的上一个节点(相当于链表,起始为-1)</span><br>	head[u]=cnt++;<span class="hljs-comment">//保存该边(最后的边)在e[i]中的编号</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SPFA</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> x)</span><span class="hljs-comment">//节点数量n,起点编号x</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">memset</span>(dist,inf,<span class="hljs-built_in">sizeof</span>(dist));<br>	<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>	<span class="hljs-built_in">memset</span>(num,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(num));<br>	dist[x]=<span class="hljs-number">0</span>;<span class="hljs-comment">//该题起点任意</span><br>	num[x]++;<span class="hljs-comment">//入队次数++</span><br>	queue&lt;<span class="hljs-type">int</span>&gt; QAQ;<br>	QAQ.<span class="hljs-built_in">push</span>(x);<br>	<span class="hljs-keyword">while</span>(!QAQ.<span class="hljs-built_in">empty</span>())<br>	&#123;<br>		<span class="hljs-type">int</span> now=QAQ.<span class="hljs-built_in">front</span>();<br>		QAQ.<span class="hljs-built_in">pop</span>();<br>		vis[now]=<span class="hljs-number">0</span>;<span class="hljs-comment">//从队列中取出</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[now];i!=<span class="hljs-number">-1</span>;i=e[i].next)<br>		&#123;<span class="hljs-comment">//遍历以now开头的所有边,尝试以x-&gt;now-&gt;to松弛x-&gt;to</span><br>			<span class="hljs-type">int</span> to=e[i].v;<span class="hljs-comment">//尝试松弛x-&gt;to的当前距离</span><br>			<span class="hljs-keyword">if</span>(dist[to]&gt;dist[now]+e[i].w)<br>			&#123;<br>				dist[to]=dist[now]+e[i].w;<span class="hljs-comment">//成功用x-&gt;now-&gt;to松弛x-&gt;to</span><br>				<span class="hljs-keyword">if</span>(!vis[to])<span class="hljs-comment">//x-&gt;to被成功松弛且to不在队列</span><br>				&#123;<br>					vis[to]=<span class="hljs-number">1</span>;<span class="hljs-comment">//标记to加入队列</span><br>					QAQ.<span class="hljs-built_in">push</span>(to);<br>					num[to]++;<span class="hljs-comment">//to加入队列次数++</span><br>					<span class="hljs-keyword">if</span>(num[to]&gt;n)<br>						<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//有负权回路,无法求最短路径</span><br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre>

<h5 id="DFS优化（负环检测）"><a href="#DFS优化（负环检测）" class="headerlink" title="DFS优化（负环检测）"></a>DFS优化（负环检测）</h5><p>请先用前向星加边。因为图有可能不连通，检测负环要枚举每个起点。</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-comment">//DFS优化</span></span><br><span class="hljs-function"></span>&#123;<br>	vis[x]=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];~i;i=e[i].next)&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(dist[v]&gt;dist[x]+e[i].w)<span class="hljs-comment">//求最短路</span><br>		&#123;<br>			dist[v]=dist[x]+e[i].w;<br>			<span class="hljs-keyword">if</span>(vis[v])<span class="hljs-comment">//存在一点在一条路径上出现多次，存在负权环</span><br>				<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>			<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">spfa</span>(v))<span class="hljs-comment">//搜到了存在负权环</span><br>				<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		&#125;<br>	&#125;<br>	vis[x]=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//未找到负权环</span><br>&#125;<br></code></pre>

<h4 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h4><pre class="highlight"><code class="hljs cpp"><span class="hljs-type">long</span> <span class="hljs-type">long</span> path[<span class="hljs-number">805</span>][<span class="hljs-number">805</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><span class="hljs-comment">//节点编号1~n</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>                <span class="hljs-keyword">if</span>(path[i][k]+path[k][j]&lt;path[i][j])<br>                &#123;<span class="hljs-comment">//当i，j的原来的边的最短距离，大于经过k点所到达的距离就替换</span><br>                    path[i][j]=path[i][k]+path[k][j];<br>                &#125;<br>&#125;<br></code></pre>

<h3 id="最大团"><a href="#最大团" class="headerlink" title="最大团"></a>最大团</h3><h4 id="最大团大小"><a href="#最大团大小" class="headerlink" title="最大团大小"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4212">最大团大小</a></h4><pre class="highlight"><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">60</span>;<br><span class="hljs-type">int</span> G[maxn][maxn],tmp[maxn][maxn];<span class="hljs-comment">//tmp[i][j]搜到第i层</span><br><span class="hljs-type">int</span> n,ans,tot,f[maxn];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> dep,<span class="hljs-type">int</span> num)</span><span class="hljs-comment">//深度(团大小),备选集合</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span>(num==<span class="hljs-number">0</span>)&#123;<br>		<span class="hljs-keyword">if</span>(dep&gt;ans)&#123;<br>			ans=dep;<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=num;i++)&#123;<br>		<span class="hljs-keyword">if</span>(dep+num-i+<span class="hljs-number">1</span>&lt;=ans)<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-type">int</span> v=tmp[dep][i];<br>		<span class="hljs-keyword">if</span>(dep+f[v]&lt;=ans)<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=num;j++)&#123;<br>			<span class="hljs-type">int</span> vv=tmp[dep][j];<br>			<span class="hljs-keyword">if</span>(G[v][vv])<br>				tmp[dep+<span class="hljs-number">1</span>][++cnt]=vv;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(dep+<span class="hljs-number">1</span>,cnt))<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxClique</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(f));<br>	f[n]=ans=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>		tot=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;j++)<br>			<span class="hljs-keyword">if</span>(G[i][j])<br>				tmp[<span class="hljs-number">1</span>][++tot]=j;<br>		<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,tot);<br>		f[i]=ans;<br>	&#125;<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//回溯法求最大团</span><br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>	<span class="hljs-type">int</span> u,v;<br>	<span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;v))<br>		G[u][v]=G[v][u]=<span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">maxClique</span>(n));<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre>

<h3 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>如果一个系统是由n个变量和<strong>m个约束条件</strong>组成，并且每个约束条件能够形成形如$x_i−x_j\le c_k$的形式，我们就称该系统为差分约束系统。</p>
<h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>先将不等号方向统一，统一为如上形式时，从$x_j$向$x_i$连一条权值为$c_k$的边。</p>
<h3 id="最小生成树-MST"><a href="#最小生成树-MST" class="headerlink" title="最小生成树(MST)"></a>最小生成树(MST)</h3><h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><p>复杂度：邻接矩阵:$O(V^2)$，邻接表:$O(ElogV)$</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">0x3f3f3f3f</span>,maxn=<span class="hljs-number">105</span>;<br><span class="hljs-type">int</span> dist[maxn][maxn],closest[maxn],lowcost[maxn];<br><span class="hljs-type">bool</span> tree[maxn];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> u0)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">memset</span>(tree,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(tree));<br>	tree[u0]=<span class="hljs-number">1</span>;<span class="hljs-comment">//加入树</span><br>	<span class="hljs-type">int</span> i,j;<br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//① 初始化,</span><br>		<span class="hljs-keyword">if</span>(i!=u0)&#123;<br>			lowcost[i]=dist[u0][i];<br>			closest[i]=u0;<span class="hljs-comment">//一开始只有u0</span><br>		&#125;<br>		<span class="hljs-keyword">else</span><br>			lowcost[u0]=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//② 每次选出来一个最近的节点</span><br>	&#123;<br>		<span class="hljs-type">int</span> temp=inf,t;<br>		<span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=n;j++)<span class="hljs-comment">//③ 在V-u中寻找最近的节点t</span><br>		&#123;<br>			<span class="hljs-keyword">if</span>(!tree[j]&amp;&amp;lowcost[j]&lt;temp)<br>			&#123;<br>				t=j;<br>				temp=lowcost[j];<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(t==u0)<span class="hljs-comment">//找不到t,没有可加入的节点,跳出</span><br>			<span class="hljs-keyword">break</span>;<br>		tree[t]=<span class="hljs-number">1</span>;<span class="hljs-comment">//找到了就加入tree</span><br>		<span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=n;j++)<span class="hljs-comment">//④ 根据加入的t节点更新lowcost和closest</span><br>		&#123;<br>			<span class="hljs-keyword">if</span>(!tree[j]&amp;&amp;dist[t][j]&lt;lowcost[j])<br>			&#123;<br>				lowcost[j]=dist[t][j];<br>				closest[j]=t;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>		ans+=lowcost[i];<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre>

<h4 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h4><p>使用并查集优化，复杂度$O(mlogm)$</p>
<p>这个不能忘吧……就先不贴了</p>
<h4 id="Boruvka"><a href="#Boruvka" class="headerlink" title="Boruvka"></a>Boruvka</h4><p>因为没有$kruskal$好写，所以一般不用于MST裸题。</p>
<p>适于处理<strong>边权由连接的两个点的点权通过某种计算方式得出</strong>的情况。</p>
<p>平均 $O(V+E)$，最坏 $O((V+E)logV)$。 </p>
<h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><ol>
<li><p>对每个连通块，处理出与其他连通块连接的最小代价，并记录这条边。</p>
</li>
<li><p>连接所有连通块与其最小连接代价的连通块，并将该边边权计入。</p>
</li>
<li><p>若剩余连通块数量大于1，重复上述步骤。</p>
</li>
</ol>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>	<span class="hljs-type">int</span> u,v,w;<br>&#125;;<br>vector&lt;edge&gt; E;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">boruvka</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//n个连通块</span><br>		fa[i]=i;<br>	<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cost</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>,<span class="hljs-title">rec</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>	<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(E.size(),<span class="hljs-literal">false</span>)</span></span>;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>	&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>			cost[i]=inf;<span class="hljs-comment">//初始化为inf</span><br>		<span class="hljs-type">int</span> cur=<span class="hljs-number">0</span>;<span class="hljs-comment">//统计不同连通块</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;E.<span class="hljs-built_in">size</span>();i++)<br>		&#123;<br>			<span class="hljs-type">int</span> a=<span class="hljs-built_in">findfa</span>(E[i].u),b=<span class="hljs-built_in">findfa</span>(E[i].v),w=E[i].w;<br>			<span class="hljs-keyword">if</span>(a==b)<br>				<span class="hljs-keyword">continue</span>;<br>			cur++;<span class="hljs-comment">//记录a,b两个连通块连接的最小代价</span><br>			<span class="hljs-keyword">if</span>(w&lt;cost[a])<br>				cost[a]=w,rec[a]=i;<span class="hljs-comment">//记录最小联通代价与相应边</span><br>			<span class="hljs-keyword">if</span>(w&lt;cost[b])<br>				cost[b]=w,rec[b]=i;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(cur==<span class="hljs-number">0</span>)<br>			<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>		&#123;<span class="hljs-comment">//最坏情况是连接的连通块数目/2</span><br>			<span class="hljs-keyword">if</span>(cost[i]&lt;inf&amp;&amp;!vis[rec[i]])<span class="hljs-comment">//与i相接的权值最小的边未加入</span><br>			&#123;<br>				<span class="hljs-built_in">Merge</span>(E[rec[i]].u,E[rec[i]].v);<span class="hljs-comment">//连接两个连通块</span><br>				ans+=E[rec[i]].w;<br>				vis[rec[i]]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//标记该边已加入,避免重复计算</span><br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre>

<h4 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h4><ul>
<li><a target="_blank" rel="noopener" href="https://www.luogu.org/problem/P1550">打井问题 </a>：将地下水源缩成一个点，添加到图中，建立MST。</li>
<li>无根MDST：建立超级源点s，向每一个节点连接一条值为INF的边，以s为根跑MDST，s的出边即为答案MDST的树根。</li>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF888G">异或生成树</a>：字典树合并连通块</li>
</ul>
<h3 id="次小生成树"><a href="#次小生成树" class="headerlink" title="次小生成树"></a>次小生成树</h3><h4 id="严格次小生成树-洛谷P4180"><a href="#严格次小生成树-洛谷P4180" class="headerlink" title="严格次小生成树(洛谷P4180)"></a>严格次小生成树(洛谷P4180)</h4><p>建立最小生成树MST，倍增维护MST上任一点到LCA最大值与次大值。</p>
<p>记录树的重量val，并对边集中选中边进行标记。倍增算出每个节点到祖先的路径最大边与严格次大边权值。枚举每一条不在MST上的的边u-&gt;v(权值w)，分别计算新树上u-&gt;lca(u,v)与v-&gt;lca(u,v)的路径<strong>最大边权M</strong>与<strong>严格次大边权m</strong>，记录<strong>最小非零</strong>增量inc&#x3D;w-M(当M&#x3D;&#x3D;w时inc&#x3D;w-m)。最后val+inc即为次小生成树重量。</p>
<p>复杂度瓶颈在排序，$O(mlogm)$</p>
<h3 id="有向图最小生成树（MDST，最小树形图）"><a href="#有向图最小生成树（MDST，最小树形图）" class="headerlink" title="有向图最小生成树（MDST，最小树形图）"></a>有向图最小生成树（MDST，最小树形图）</h3><ul>
<li><p>树形图：有向图$G&#x3D;(V,E)$中，选定根节点$root$，$G$的一个以$root$为根节点的子图$T$，$T$中$root$到任意其他节点路径<strong>存在且唯一</strong>。则$T$称为有向图生成树&#x2F;树形图DST。</p>
</li>
<li><p>最小树形图：带权有向图$G&#x3D;(V,E,w)$中边权总和最小的DST，即Minimum Directed Spanning Trees。</p>
</li>
<li><p>特点：</p>
<ul>
<li>MDST上一定有且仅有$n-1$条边</li>
<li>根节点入度为0，其他节点入度为1</li>
</ul>
</li>
</ul>
<h4 id="朱刘算法（Edmonds-算法）"><a href="#朱刘算法（Edmonds-算法）" class="headerlink" title="朱刘算法（Edmonds 算法）"></a>朱刘算法（Edmonds 算法）</h4><h5 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h5><ol>
<li>对每个非根节点，找出权值最小的入边（n-1条），记为集合$E$。若$E$不存在，则MDST一定不存在。</li>
<li>判断E中是否成环，成环转到步骤3，否则转到步骤4。</li>
<li>若成环则进行<strong>缩点</strong>，同时更新指向该环的所有边的权值，此更新等效于删去环上的一条边。<ul>
<li>记该环为$C$，在新图$G_1$中收缩为点$u$，则对于在$G$图中不在环上的且指向该环上任一点$v$的一条边$&lt;v_1,v&gt;$，该边权值记为$w$，在$G_1$中存在边$&lt;v_1,u&gt;$与之对应，且该边权值$W_{G_1}(&lt;v_1,u&gt;)$&#x3D;$W_{G}(&lt;v_1,v&gt;)-w$。</li>
<li>因为任何一个节点入度都不会大于1，在环$C$上已经为点$v$选择了一条入边，所以要根据改边权值更新其他点$v$入边权值，当接下来选择了其他指向$v$的边时，相当于删去了$C$上指向$v$的边。</li>
<li>转到步骤1，直到证明不存在或者求得。</li>
</ul>
</li>
<li>不成环则展开收缩点，获得MDST。若仅须获得MDST的权值，则不需要展开。</li>
</ol>
<h5 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h5><p>朱刘算法，不包括展开部分，未优化，复杂度$O(VE)$</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1005</span>,inf=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><br>&#123;<br>	<span class="hljs-type">int</span> u,v,w;<br>	<span class="hljs-built_in">edge</span>(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w):<br>		<span class="hljs-built_in">u</span>(u),<span class="hljs-built_in">v</span>(v),<span class="hljs-built_in">w</span>(w)&#123;&#125;<br>&#125;;<br>vector&lt;edge&gt; G;<span class="hljs-comment">//该算法会修改边</span><br><span class="hljs-type">int</span> id[maxn],in[maxn],pre[maxn],vis[maxn];<span class="hljs-comment">//in[x]表示x入边最小权,pre[x]表示x最小入边的出点</span><br><span class="hljs-function">ll <span class="hljs-title">zltree</span><span class="hljs-params">(<span class="hljs-type">int</span> root,<span class="hljs-type">int</span> n)</span><span class="hljs-comment">//id[x]为x节点在G图上的编号</span></span><br><span class="hljs-function"></span>&#123;<br>	ll ans=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>	&#123;<br>		<span class="hljs-built_in">fill</span>(in,in+n+<span class="hljs-number">1</span>,inf);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;e:G)<br>			<span class="hljs-keyword">if</span>(e.u!=e.v&amp;&amp;e.w&lt;in[e.v])<br>			&#123;<br>				pre[e.v]=e.u;<span class="hljs-comment">//记录最小入边出点</span><br>				in[e.v]=e.w;<span class="hljs-comment">//记录最小入边权</span><br>			&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>			<span class="hljs-keyword">if</span>(i!=root&amp;&amp;in[i]==inf)<br>				<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//存在非根点没有入边,无MDST</span><br>		<span class="hljs-built_in">fill</span>(id,id+n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>		<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>		<span class="hljs-type">int</span> tn=<span class="hljs-number">0</span>,v;<span class="hljs-comment">//tn记录环的数量</span><br>		in[root]=<span class="hljs-number">0</span>;<span class="hljs-comment">//根节点无入边,权为0(这样不用特判)</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//找环</span><br>		&#123;<br>			ans+=in[v=i];<span class="hljs-comment">//加v入边贡献</span><br>			<span class="hljs-keyword">while</span>(vis[v]!=i&amp;&amp;!id[v]&amp;&amp;v!=root)<span class="hljs-comment">//</span><br>				vis[v]=i,v=pre[v];<span class="hljs-comment">//检查v的最小入边出点,并标记vis为i</span><br>			<span class="hljs-keyword">if</span>(v!=root&amp;&amp;!id[v])<br>			&#123;<br>				id[v]=++tn;<span class="hljs-comment">//标记环的编号</span><br>				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u=pre[v];u!=v;u=pre[u])<br>					id[u]=tn;<span class="hljs-comment">//将v所在环打上同一个标记</span><br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(tn==<span class="hljs-number">0</span>)<span class="hljs-comment">//无环</span><br>			<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>			<span class="hljs-keyword">if</span>(!id[i])<span class="hljs-comment">//给不在环上的点新编号</span><br>				id[i]=++tn;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-type">int</span>)G.<span class="hljs-built_in">size</span>();)<span class="hljs-comment">//更新为新图G1</span><br>		&#123;<br>			<span class="hljs-keyword">auto</span> &amp;e=G[i];<br>			v=e.v;<br>			e.u=id[e.u],e.v=id[e.v];<br>			<span class="hljs-keyword">if</span>(e.u!=e.v)<span class="hljs-comment">//更新指向环的边权</span><br>				e.w-=in[v],i++;<br>			<span class="hljs-keyword">else</span><br>			&#123;<br>				<span class="hljs-built_in">swap</span>(e,G.<span class="hljs-built_in">back</span>());<br>				G.<span class="hljs-built_in">pop_back</span>();<br>			&#125;<br>		&#125;<br>		n=tn;<span class="hljs-comment">//更新新图的点数</span><br>		root=id[root];<span class="hljs-comment">//更新新图上根节点编号</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> n,m,r,u,v,w;<br>	cin&gt;&gt;n&gt;&gt;m&gt;&gt;r;<span class="hljs-comment">//n节点,m条边,根节点r</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>	&#123;<br>		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>		G.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">edge</span>(u,v,w));<span class="hljs-comment">//有向</span><br>	&#125;<br>	cout&lt;&lt;<span class="hljs-built_in">zltree</span>(r,n)&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre>

<h3 id="虚树"><a href="#虚树" class="headerlink" title="虚树"></a>虚树</h3><p>虚树是在树形dp中使用的一种特殊优化，适用于树中仅有<strong>少量关键节点</strong>且普通节点很多的情况。可以将关键点和他们的LCA拿出来另建一棵树，并在这棵树上另外进行树形dp。</p>
<h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>在原树上进行dfs，进行LCA预处理，同时得到原树上的dfs序，方便之后虚树构造，此外还可以进行一些dp预处理，便于进行虚树上的第二次dp。</li>
<li>确定关键节点集合，并按照dfs序排序。</li>
<li>通过单调栈及LCA算法构建出虚树。</li>
<li>在虚树上进行树形dp求解。</li>
</ol>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><pre class="highlight"><code class="hljs cpp"><span class="hljs-built_in">sort</span>(h+<span class="hljs-number">1</span>,h+k+<span class="hljs-number">1</span>,[](<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;x,<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;y)&#123;<br>    <span class="hljs-keyword">return</span> dfn[x]&lt;dfn[y];<span class="hljs-comment">//按dfs序排序</span><br>&#125;);<br>stk[top=<span class="hljs-number">1</span>]=h[<span class="hljs-number">1</span>];<br>cnt2=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=k;i++)<br>&#123;<br>    <span class="hljs-type">int</span> now=h[i];<br>    <span class="hljs-type">int</span> lc=<span class="hljs-built_in">lca</span>(now,stk[top]);<span class="hljs-comment">//最近公共祖先</span><br>    <span class="hljs-comment">//printf(&quot;lca(%d,%d)=%d\n&quot;,now,stk[top],lc);</span><br>    <span class="hljs-keyword">while</span>(top&gt;<span class="hljs-number">1</span>&amp;&amp;dfn[lc]&lt;=dfn[stk[top<span class="hljs-number">-1</span>]])<span class="hljs-comment">//情况4,=是情况3</span><br>    &#123;<span class="hljs-comment">//不断将top送入虚树</span><br>        <span class="hljs-built_in">adde</span>(stk[top<span class="hljs-number">-1</span>],stk[top]);<span class="hljs-comment">//前向星加边,构建新树</span><br>        top--;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dfn[lc]&lt;dfn[stk[top]])<span class="hljs-comment">//情况2</span><br>    &#123;<span class="hljs-comment">//加边,top出栈,lc和now入栈</span><br>        <span class="hljs-built_in">adde</span>(lc,stk[top]);<br>        stk[top]=lc;<br>    &#125;<span class="hljs-comment">//否则为情况1</span><br>    stk[++top]=now;<br>&#125;<br><span class="hljs-keyword">while</span>(--top)<br>    <span class="hljs-built_in">adde</span>(stk[top],stk[top+<span class="hljs-number">1</span>]);<br></code></pre>



<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>只适用于DAG。</p>
<p>使用队列（要求字典序时使用优先队列），在邻接表存边时统计每个结点的入度，入度为0则入队。按出队顺序编号，删除以该节点为尾的边，该边边头<strong>入度减1</strong>，若变为0则入队。直到队列为空，得到top数组与node数组。</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">105</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt; G[maxn];<br><span class="hljs-type">int</span> n,m,top[maxn],node[maxn];<span class="hljs-comment">//节点i拓扑顺序为top[i]</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">topsort</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//要求字典序：优先队列，小根堆</span><br>	priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt; &gt; QAQ;<span class="hljs-comment">//若要求字典序用优先队列</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>		<span class="hljs-keyword">if</span>(G[i][<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>)<span class="hljs-comment">//G[i][0]表示入度</span><br>			QAQ.<span class="hljs-built_in">push</span>(i);<br>	<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(!QAQ.<span class="hljs-built_in">empty</span>())<br>	&#123;<br>		<span class="hljs-type">int</span> x=QAQ.<span class="hljs-built_in">top</span>();<br>		top[x]=++cnt;<span class="hljs-comment">//top[x]表示x号节点的次序编号</span><br>		QAQ.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;G[x].<span class="hljs-built_in">size</span>();i++)<br>		&#123;<br>			<span class="hljs-keyword">if</span>(--G[G[x][i]][<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>)<span class="hljs-comment">//节点入度为0时入队</span><br>				QAQ.<span class="hljs-built_in">push</span>(G[x][i]);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span>(cnt!=n)<span class="hljs-comment">//</span><br>		<span class="hljs-keyword">return</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>		node[top[i]]=i;<span class="hljs-comment">//node[i]表示排序为i的节点为node[i]</span><br><span class="hljs-comment">//	for(int i=1;i&lt;=n;i++)</span><br><span class="hljs-comment">//		printf(&quot;%d%c&quot;,node[i],i&lt;n?&#x27; &#x27;:&#x27;\n&#x27;);//输出拓扑排序后的节点</span><br>	<span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;m&amp;&amp;(n||m))&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			G[i].<span class="hljs-built_in">clear</span>();<span class="hljs-comment">//注意清空</span><br>			G[i].<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//G[i][0]用来统计节点i的入度</span><br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>			<span class="hljs-type">int</span> u,v;<br>			cin&gt;&gt;u&gt;&gt;v;<br>			G[u].<span class="hljs-built_in">push_back</span>(v);<span class="hljs-comment">//向G中加边</span><br>			G[v][<span class="hljs-number">0</span>]++;<span class="hljs-comment">//v的入度+1</span><br>		&#125;<br>		<span class="hljs-built_in">topsort</span>();<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre>

<h3 id="补图搜索"><a href="#补图搜索" class="headerlink" title="补图搜索"></a>补图搜索</h3><p>也是很套路的题了，使用$set$数组来代替邻接表，用$set.find(v)$来确定边是否在图中。并查集、DFS、BFS都可以做。</p>
<h4 id="补图连通块-0-1-MST"><a href="#补图连通块-0-1-MST" class="headerlink" title="补图连通块 0-1 MST "></a>补图连通块 <a target="_blank" rel="noopener" href="https://codeforc.es/contest/1243/problem/D">0-1 MST </a></h4><p>初始化$ans&#x3D;0$，并将所有的点放进一个未访问集合$unvis$中，当集合非空时，取出$unvis.begin()$记为$now$并从集合中去掉，并从该点开始BFS，遍历$nuvis$集，并在邻接表$set[now]$中查询，若$set.find()$未找到，则说明该边为补边。</p>
<pre class="highlight"><code class="hljs cpp">set&lt;<span class="hljs-type">int</span>&gt; G[maxn];<span class="hljs-comment">//使用set存原图,加快速度</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>	set&lt;<span class="hljs-type">int</span>&gt; unvis;<span class="hljs-comment">//已访问节点,从原图上删除</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>		unvis.<span class="hljs-built_in">insert</span>(i);<span class="hljs-comment">//将所有点加入到nuvis集合中</span><br>	<span class="hljs-keyword">while</span>(!unvis.<span class="hljs-built_in">empty</span>())<span class="hljs-comment">//BFS求连通块个数</span><br>	&#123;<br>		ans++;<span class="hljs-comment">//从未访问集里拿出新的元素,新增一个连通块</span><br>		<span class="hljs-type">int</span> now=*(unvis.<span class="hljs-built_in">begin</span>());<span class="hljs-comment">//取出第一个</span><br>		unvis.<span class="hljs-built_in">erase</span>(now);<br>		queue&lt;<span class="hljs-type">int</span>&gt; QwQ;<br>		QwQ.<span class="hljs-built_in">push</span>(now);<br>		<span class="hljs-keyword">while</span>(!QwQ.<span class="hljs-built_in">empty</span>())<span class="hljs-comment">//找出与now联通的节点,并从unvis中删去</span><br>		&#123;<br>			<span class="hljs-type">int</span> nex=QwQ.<span class="hljs-built_in">front</span>();<span class="hljs-comment">//与now联通的点之一</span><br>			QwQ.<span class="hljs-built_in">pop</span>();<br>			vector&lt;<span class="hljs-type">int</span>&gt; v1;<span class="hljs-comment">//记录要删去的节点</span><br>			<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:unvis)<span class="hljs-comment">//遍历未访问集合</span><br>				<span class="hljs-keyword">if</span>(G[nex].<span class="hljs-built_in">find</span>(i)==G[nex].<span class="hljs-built_in">end</span>())<br>				&#123;<span class="hljs-comment">//now与i由补边连接,权重为0</span><br>					v1.<span class="hljs-built_in">push_back</span>(i);<br>					QwQ.<span class="hljs-built_in">push</span>(i);<span class="hljs-comment">//放进队列里,继续向下求联通点</span><br>				&#125;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;v1.<span class="hljs-built_in">size</span>();i++)<br>				unvis.<span class="hljs-built_in">erase</span>(v1[i]);<span class="hljs-comment">//在集合中删去搜到的联通节点</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre>

<h3 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h3><h4 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h4><h5 id="Tarjan缩点-DAG-拓扑排序dp"><a href="#Tarjan缩点-DAG-拓扑排序dp" class="headerlink" title="Tarjan缩点+DAG 拓扑排序dp"></a>Tarjan缩点+DAG 拓扑排序dp</h5><p>n个点m条边的有向图，每个点有一个权值，求一条路径，使路径经过的点权值之和最大。</p>
<p>思路：使用<strong>Tarjan缩点</strong>建立新图DAG，在DAG上进行拓扑排序并进行DP。</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">100005</span>;<br><span class="hljs-type">int</span> tot=<span class="hljs-number">0</span>,Index=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> stk[maxn],dfn[maxn],low[maxn],belong[maxn];<br><span class="hljs-type">int</span> val[maxn],rec[maxn];<span class="hljs-comment">//每个强连通分量的值</span><br><span class="hljs-type">bool</span> vis[maxn];<br>vector&lt;<span class="hljs-type">int</span>&gt; G[maxn];<span class="hljs-comment">//邻接表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-comment">//标准的Tarjan缩点</span></span><br><span class="hljs-function"></span>&#123;<br>	dfn[x]=low[x]=++tim;<span class="hljs-comment">//dfs序</span><br>	stk[++Index]=x;<br>	vis[x]=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> &amp;v:G[x])<br>	&#123;<br>		<span class="hljs-keyword">if</span>(!dfn[v])<span class="hljs-comment">//v未被访问</span><br>		&#123;<br>			<span class="hljs-built_in">tarjan</span>(v);<br>			low[x]=<span class="hljs-built_in">min</span>(low[x],low[v]);<span class="hljs-comment">//回溯时更新low</span><br>		&#125;<span class="hljs-comment">//low[x]为x所在强连通分量最早起始节点</span><br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vis[v])<span class="hljs-comment">//v在栈中,说明有环</span><br>			low[x]=<span class="hljs-built_in">min</span>(low[x],dfn[v]);<span class="hljs-comment">//更新起点为最早的那个</span><br>	&#125;<br>	<span class="hljs-keyword">if</span>(low[x]==dfn[x])<br>	&#123;<span class="hljs-comment">//以x为起点的强连通分量</span><br>		cnt++;<span class="hljs-comment">//新图节点++</span><br>		<span class="hljs-keyword">do</span>&#123;<br>			belong[stk[Index]]=cnt;<br>			rec[cnt]+=val[stk[Index]];<span class="hljs-comment">//缩点后的权值</span><br>			vis[stk[Index]]=<span class="hljs-number">0</span>;<br>			Index--;<br>		&#125;<span class="hljs-keyword">while</span>(stk[Index+<span class="hljs-number">1</span>]!=x);<br>	&#125;<br>&#125;<br>vector&lt;<span class="hljs-type">int</span>&gt; Gra[maxn];<br><span class="hljs-type">int</span> dp[maxn],top[maxn],into[maxn];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">topsort</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>	queue&lt;<span class="hljs-type">int</span>&gt; QAQ;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;i++)<br>	&#123;<br>		<span class="hljs-keyword">if</span>(!into[i])<br>			QAQ.<span class="hljs-built_in">push</span>(i);<br>		dp[i]=rec[i];<br>	&#125;<br>	<span class="hljs-type">int</span> flag=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(!QAQ.<span class="hljs-built_in">empty</span>())<br>	&#123;<br>		<span class="hljs-type">int</span> x=QAQ.<span class="hljs-built_in">front</span>();<br>		QAQ.<span class="hljs-built_in">pop</span>();<br>		top[x]=++flag;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;Gra[x].<span class="hljs-built_in">size</span>();i++)<br>		&#123;<br>			dp[Gra[x][i]]=<span class="hljs-built_in">max</span>(dp[Gra[x][i]],dp[x]+rec[Gra[x][i]]);<br>			<span class="hljs-keyword">if</span>(--into[Gra[x][i]]==<span class="hljs-number">0</span>)<br>				QAQ.<span class="hljs-built_in">push</span>(Gra[x][i]);<br>		&#125;<br>	&#125;<br>	<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;i++)<br>		ans=<span class="hljs-built_in">max</span>(ans,dp[i]);<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> n,m;<br>	cin&gt;&gt;n&gt;&gt;m;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>		cin&gt;&gt;val[i];<span class="hljs-comment">//每个点的值</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>	&#123;<br>		<span class="hljs-type">int</span> u,v;<br>		cin&gt;&gt;u&gt;&gt;v;<br>		G[u].<span class="hljs-built_in">push_back</span>(v);<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//Tarjan缩点部分</span><br>		<span class="hljs-keyword">if</span>(!dfn[i])<br>			<span class="hljs-built_in">tarjan</span>(i);<span class="hljs-comment">//缩点</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<span class="hljs-comment">//拓扑排序部分</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;G[i].<span class="hljs-built_in">size</span>();j++)<br>		&#123;<br>			<span class="hljs-type">int</span> x=belong[i],y=belong[G[i][j]];<br>			<span class="hljs-keyword">if</span>(x!=y)<br>			&#123;<br>				Gra[x].<span class="hljs-built_in">push_back</span>(y);<span class="hljs-comment">//建立新图DAG</span><br>				into[y]++;<br>			&#125;<br>		&#125;<br>	cout&lt;&lt;<span class="hljs-built_in">topsort</span>()&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre>

<h5 id="Tarjan无向图求割点"><a href="#Tarjan无向图求割点" class="headerlink" title="Tarjan无向图求割点"></a>Tarjan无向图求割点</h5><pre class="highlight"><code class="hljs cpp"><span class="hljs-type">int</span> tot=<span class="hljs-number">0</span>,Index=<span class="hljs-number">0</span>,ans=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> dfn[maxn],low[maxn],stk[maxn];<br><span class="hljs-type">bool</span> vis[maxn],isc[maxn];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>	dfn[x]=low[x]=++tot;<br>	<span class="hljs-type">int</span> child=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;G[x].<span class="hljs-built_in">size</span>();i++)<br>	&#123;<br>		<span class="hljs-type">int</span> v=G[x][i];<br>		<span class="hljs-keyword">if</span>(!dfn[v])<br>		&#123;<br>			<span class="hljs-built_in">tarjan</span>(v,x);<br>			low[x]=<span class="hljs-built_in">min</span>(low[x],low[v]);<br>			<span class="hljs-keyword">if</span>(x==fa)<br>				child++;<br>			<span class="hljs-keyword">if</span>(x!=fa&amp;&amp;low[v]&gt;=dfn[x])<br>				isc[x]=<span class="hljs-number">1</span>;<br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(v!=fa)<span class="hljs-comment">//不同之处</span><br>			low[x]=<span class="hljs-built_in">min</span>(low[x],dfn[v]);<br>	&#125;<br>	<span class="hljs-keyword">if</span>(x==fa&amp;&amp;child&gt;=<span class="hljs-number">2</span>)<br>		isc[x]=<span class="hljs-number">1</span>;<br>&#125;<br></code></pre>

<h5 id="无向图求桥"><a href="#无向图求桥" class="headerlink" title="无向图求桥"></a>无向图求桥</h5><pre class="highlight"><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>	dfn[x]=low[x]=++tot;<br>	<span class="hljs-type">bool</span> vis=<span class="hljs-number">0</span>;<span class="hljs-comment">//处理重边要加上,表示这个节点还没有被子树搜到</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;G[x].<span class="hljs-built_in">size</span>();i++)<br>	&#123;<br>		<span class="hljs-type">int</span> v=G[x][i].v,no=G[x][i].no;<br>		<span class="hljs-keyword">if</span>(!dfn[v])<br>		&#123;<br>			<span class="hljs-built_in">tarjan</span>(v,x);<br>			<span class="hljs-keyword">if</span>(low[v]&gt;dfn[x])<span class="hljs-comment">//讨论桥是大于</span><br>			&#123;<br>				bri[no]=<span class="hljs-number">1</span>;<span class="hljs-comment">//法1，对桥的编号做标记</span><br><span class="hljs-comment">//				pair&lt;int,int&gt; tem;//法二，将桥存到新的数组中</span><br><span class="hljs-comment">//				tem.first=x,tem.second=v;</span><br><span class="hljs-comment">//				ans[flag++]=tem;</span><br>			&#125;<br>			low[x]=<span class="hljs-built_in">min</span>(low[x],low[v]);<br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dfn[x]&gt;dfn[v])<span class="hljs-comment">//可改为无条件？</span><br>		&#123;<br>			<span class="hljs-keyword">if</span>(v==fa&amp;&amp;!vis)<br>				vis=<span class="hljs-number">1</span>;<span class="hljs-comment">//除了第一次，每次回到父节点都用父节点的值更新当前结点的值</span><br>			<span class="hljs-keyword">else</span><span class="hljs-comment">//之前是v!=fa时才用父节点值更新该点的值</span><br>				low[x]=<span class="hljs-built_in">min</span>(low[x],dfn[v]);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre>

<h4 id="2-SAT问题"><a href="#2-SAT问题" class="headerlink" title="2-SAT问题"></a>2-SAT问题</h4><h5 id="流程-2"><a href="#流程-2" class="headerlink" title="流程"></a>流程</h5><ol>
<li>将点$i$拆成$i$与$n+i$两个点，分别表示点$i$状态为$0$或$1$，二者必须且只能取其一。</li>
<li>根据所给逻辑关系建图，将$2n$个点进行缩点。</li>
<li>若存在一对拆点位于同一个强连通分量，则无解。</li>
<li>否则对于每个点对，选择<strong>分量编号</strong>较小的点（即拓扑序较大的那个）。</li>
</ol>
<h5 id="建图方式"><a href="#建图方式" class="headerlink" title="建图方式"></a>建图方式</h5><table>
<thead>
<tr>
<th>逻辑表达式</th>
<th>连接的有向边(推导关系)</th>
</tr>
</thead>
<tbody><tr>
<td>$a\land b&#x3D;1$</td>
<td>$\lnot a\rightarrow a,\lnot b \rightarrow b$</td>
</tr>
<tr>
<td>$a\land b&#x3D;0$</td>
<td>$a\rightarrow \lnot b,b \rightarrow \lnot a$</td>
</tr>
<tr>
<td>$a \lor b&#x3D;1$</td>
<td>$\lnot a\rightarrow b,\lnot b \rightarrow a$</td>
</tr>
<tr>
<td>$a \lor b&#x3D;0$</td>
<td>$a\rightarrow \lnot a,b \rightarrow \lnot b$</td>
</tr>
<tr>
<td>$a\oplus b&#x3D;1$</td>
<td>$\lnot a\rightarrow b,b \rightarrow \lnot a,\lnot b \rightarrow a,a\rightarrow \lnot b$</td>
</tr>
<tr>
<td>$a\oplus b&#x3D;0$，或$a\odot b&#x3D;1$</td>
<td>$a\rightarrow b,b\rightarrow a,\lnot a\rightarrow \lnot b,\lnot b\rightarrow \lnot a$</td>
</tr>
<tr>
<td>$a\rightarrow b$</td>
<td>$a\rightarrow b,\lnot b\rightarrow\lnot a$</td>
</tr>
<tr>
<td>$\lnot a\rightarrow\lnot b$</td>
<td>$\lnot a\rightarrow\lnot b,b\rightarrow a$</td>
</tr>
</tbody></table>
<h3 id="最近公共祖先-LCA"><a href="#最近公共祖先-LCA" class="headerlink" title="最近公共祖先(LCA)"></a>最近公共祖先(LCA)</h3><p>因为LCA只适用于树，所以经常和生成树在一起考。</p>
<h4 id="倍增"><a href="#倍增" class="headerlink" title="倍增"></a>倍增</h4><pre class="highlight"><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">100005</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxl=<span class="hljs-number">30</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt; G[maxn];<span class="hljs-comment">//无权边,也可以选择链式前向星存图</span><br><span class="hljs-type">int</span> gene[maxn][maxl],depth[maxn],lg[maxn];<br><span class="hljs-type">int</span> nodes[maxn];<span class="hljs-comment">//子树结点的数量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>	depth[x]=depth[fa]+<span class="hljs-number">1</span>;<br>	gene[x][<span class="hljs-number">0</span>]=fa;<br>	nodes[x]=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;i)&lt;=depth[x];i++)<span class="hljs-comment">//倍增</span><br>		gene[x][i]=gene[gene[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;G[x].<span class="hljs-built_in">size</span>();i++)<br>		<span class="hljs-keyword">if</span>(G[x][i]!=fa)<br>		&#123;<br>			<span class="hljs-built_in">dfs</span>(G[x][i],x);<span class="hljs-comment">//在dfs前后加语句可以求出许多有趣的东西</span><br>			nodes[x]+=nodes[G[x][i]];<br>		&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span>(depth[x]&lt;depth[y])<span class="hljs-comment">//保证x深度≥y</span><br>		<span class="hljs-built_in">swap</span>(x,y);<br>	<span class="hljs-keyword">while</span>(depth[x]&gt;depth[y])<span class="hljs-comment">//将x提到同一高度</span><br>		x=gene[x][lg[depth[x]-depth[y]<span class="hljs-number">-1</span>]];<br>	<span class="hljs-keyword">if</span>(x==y)<span class="hljs-comment">//是同一个节点</span><br>		<span class="hljs-keyword">return</span> x;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lg[depth[x]];i&gt;=<span class="hljs-number">0</span>;i--)<br>		<span class="hljs-keyword">if</span>(gene[x][i]!=gene[y][i])<br>		&#123;<span class="hljs-comment">//二分思想,直到跳到LCA的下面一层</span><br>			x=gene[x][i];<br>			y=gene[y][i];<br>		&#125;<br>	<span class="hljs-keyword">return</span> gene[x][<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dist</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span><span class="hljs-comment">//x节点到y结点的距离</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> tem=<span class="hljs-built_in">lca</span>(x,y);<br>	<span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(<span class="hljs-built_in">abs</span>(depth[x]-depth[tem])+<span class="hljs-built_in">abs</span>(depth[y]-depth[tem]));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">memset</span>(nodes,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(nodes));<br><span class="hljs-comment">//	memset(gene,0,sizeof(gene));</span><br>	depth[s]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//预处理出log2(i)+1的值</span><br>		lg[i]=lg[i<span class="hljs-number">-1</span>]+((<span class="hljs-number">1</span>&lt;&lt;(lg[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>))==i);<span class="hljs-comment">//不要写错</span><br>	<span class="hljs-built_in">dfs</span>(s,<span class="hljs-number">0</span>);<br>&#125;<br></code></pre>

<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><ul>
<li><p>次小生成树：<a target="_blank" rel="noopener" href="https://www.luogu.org/problem/P4180">P4180严格次小生成树</a></p>
</li>
<li><p>树上两条路径是否相交：<a target="_blank" rel="noopener" href="https://www.luogu.org/problem/P3398">仓鼠找sugar </a></p>
<pre class="highlight"><code class="hljs cpp">u=<span class="hljs-built_in">lca</span>(a,b),v=<span class="hljs-built_in">lca</span>(c,d);<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">dist</span>(u,c)+<span class="hljs-built_in">dist</span>(u,d)==<span class="hljs-built_in">dist</span>(c,d)||<span class="hljs-built_in">dist</span>(v,a)+<span class="hljs-built_in">dist</span>(v,b)==<span class="hljs-built_in">dist</span>(a,b))<br>	cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br></code></pre>
</li>
<li><p>给定节点，求以它为LCA的节点有多少种组合：<a target="_blank" rel="noopener" href="https://www.luogu.org/problem/P5002">找祖先 </a>，DFS回溯求出</p>
</li>
<li><p>分类讨论求树上到任意两点距离相等的点的个数（重点讨论中节点与LCA关系）：<a target="_blank" rel="noopener" href="https://www.luogu.org/problem/CF519E">A and B and Lecture Rooms </a></p>
</li>
<li><p>求两节点路径上最大&#x2F;最小边的权值，若求最小即为求容量：<a target="_blank" rel="noopener" href="https://www.luogu.org/problem/P1967">货车运输 </a>，DFS时倍增求出路径上min</p>
</li>
</ul>
<h3 id="树上差分"><a href="#树上差分" class="headerlink" title="树上差分"></a>树上差分</h3><p>用于求解一些<strong>树上路径</strong>问题。</p>
<p>常见问法：将一棵树上从u到v路径上的<strong>点&#x2F;边</strong>的权值加上x，询问<strong>某点&#x2F;边</strong>的权值。</p>
<p>$O(1)$修改，$O(n)$查询，复杂度决定要离线。</p>
<p>强行在线可用<strong>树链剖分</strong>$O(logn \times logn)$修改，$O(logn \times logn)$查询。</p>
<p>修改差分数组之前先用DFS倍增求出各节点LCA。</p>
<p>差分数组记为power[maxn]，直接修改即可，查询时调用DFS</p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul>
<li>树上任意两点之间有且只有一条路径</li>
<li>一个节点只有一个父节点</li>
<li>$x$节点到$y$结点的路线为：$x→lca(x,y)→y$</li>
</ul>
<h4 id="点的差分"><a href="#点的差分" class="headerlink" title="点的差分"></a>点的差分</h4><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><p>每次修改使$u$到$v$的路径上所有节点权值+1（包括端点），询问某一节点权值。</p>
<h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><p>$power[u]++,\ power[v]++,\ power[lca(u,v)]–,\ power[father[lca(u,v)]]–$</p>
<h4 id="边的差分"><a href="#边的差分" class="headerlink" title="边的差分"></a>边的差分</h4><h5 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h5><p><strong>以点代边</strong>，$power[x]$代表$x$节点到父节点的边的权值。</p>
<p>若查询边的权值，则需要按输入顺序对每条边进行编号。</p>
<p>每次修改使节点$u$与节点$v$之间<strong>所有边</strong>权值+1，询问某一条边权值。</p>
<h5 id="修改-1"><a href="#修改-1" class="headerlink" title="修改"></a>修改</h5><p>$power[u]++,\ power[v]++,\ power[lca(u,v)]-&#x3D;2$</p>
<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><pre class="highlight"><code class="hljs cpp"><span class="hljs-type">int</span> power[maxn];<span class="hljs-comment">//power[x]即为x节点权值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-comment">//查询，求出所有节点权值</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];~i;i=G[i].nex)<span class="hljs-comment">//枚举x所有子节点</span><br>		<span class="hljs-keyword">if</span>(G[i].v!=gene[x][<span class="hljs-number">0</span>])<span class="hljs-comment">//不为x父节点</span><br>		&#123;<br>			<span class="hljs-built_in">dfs</span>(G[i].v);<span class="hljs-comment">//</span><br>			power[x]+=power[G[i].v];<br>		&#125;<br>	ans=<span class="hljs-built_in">max</span>(ans,power[x]);<br>&#125;<br></code></pre>

<h3 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h3><p>注意以点代边的思想</p>
<ul>
<li>功能<ol>
<li>更新&#x2F;查询某个节点子树的权值</li>
<li>更新&#x2F;查询树上两个节点间所有点的权值</li>
</ol>
</li>
<li>性质<ol>
<li>子树的时间戳一定全部小于父节点，并且连续（所以可用线段树维护）</li>
<li>任何一条路径都是由重链的一部分与重链间的叶子节点构成</li>
<li>任何父节点都一定在一条重链上（所以可用top的父节点跳链）</li>
</ol>
</li>
<li>例题<ol>
<li><a target="_blank" rel="noopener" href="https://www.luogu.org/problem/P3384">P3384 树链剖分 </a></li>
</ol>
</li>
</ul>
<h4 id="通用模板"><a href="#通用模板" class="headerlink" title="通用模板"></a>通用模板</h4><pre class="highlight"><code class="hljs cpp"><span class="hljs-type">int</span> n,tot=<span class="hljs-number">0</span>,head[maxn];<br>ll val[maxn];<span class="hljs-comment">//给定的每个节点的权值</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><br>&#123;<span class="hljs-comment">//边权一般不必记录到这里</span><br>	<span class="hljs-type">int</span> v,w,nex;<br>&#125; e[maxn&lt;&lt;<span class="hljs-number">1</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w=<span class="hljs-number">0</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>	e[++tot].v=v;<br>	e[tot].w=w;<br>	e[tot].nex=head[u];<br>	head[u]=tot;<br>&#125;<br><span class="hljs-comment">//以点代边:以节点的权值代表该节点到父节点边的权值,修改与查询跳过链顶点即可(最终的参数改为dfn[x]+1)</span><br><span class="hljs-comment">//使用前先初始化,然后加边,dfs1(rt,rt),dfs2(rt,rt),build(1,1,n),使用封装好的函数修改+查询</span><br><span class="hljs-keyword">namespace</span> hld&#123;<span class="hljs-comment">//heavy-light decomposition</span><br>	<span class="hljs-type">int</span> father[maxn],son[maxn],depth[maxn],siz[maxn];<span class="hljs-comment">//父节点,重儿子节点,深度,子树大小</span><br>	<span class="hljs-type">int</span> tim=<span class="hljs-number">0</span>,dfn[maxn],rk[maxn],top[maxn];<span class="hljs-comment">//计数器,时间戳(节点编号),访问顺序,节点所在重链的顶部节点</span><br>	ll w[maxn];<span class="hljs-comment">//节点dfs序对应权值</span><br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		tim=tot=<span class="hljs-number">0</span>;<br>		<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>		<span class="hljs-built_in">memset</span>(depth,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(depth));<br><span class="hljs-comment">//		memset(father,0,sizeof(father));</span><br>		<span class="hljs-built_in">memset</span>(son,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(son));<br><span class="hljs-comment">//		memset(top,0,sizeof(top));</span><br><span class="hljs-comment">//		memset(dfn,0,sizeof(dfn));</span><br>	&#125;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function">	</span>&#123;<span class="hljs-comment">//预处理出深度,父节点,重儿子,子树大小</span><br>		depth[x]=depth[fa]+<span class="hljs-number">1</span>;<br>		father[x]=fa;<br>		siz[x]=<span class="hljs-number">1</span>;<br>		<span class="hljs-type">int</span> maxsiz=<span class="hljs-number">-1</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];~i;i=e[i].nex)<br>		&#123;<span class="hljs-comment">//遍历儿子节点</span><br>			<span class="hljs-type">int</span> v=e[i].v;<br>			<span class="hljs-keyword">if</span>(v==fa)<br>				<span class="hljs-keyword">continue</span>;<br><span class="hljs-comment">//			val[v]=e[i].w;//以点代边:将边的权值赋给边头节点</span><br>			<span class="hljs-built_in">dfs1</span>(v,x);<br>			siz[x]+=siz[v];<span class="hljs-comment">//加上儿子的子树大小</span><br>			<span class="hljs-keyword">if</span>(maxsiz&lt;siz[v])<br>			&#123;<br>				son[x]=v;<br>				maxsiz=siz[v];<span class="hljs-comment">//记录重儿子</span><br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> t)</span></span><br><span class="hljs-function">	</span>&#123;<span class="hljs-comment">//按dfs序对各节点重新编号,并记录对应权值到w数组</span><br>		dfn[x]=++tim;<span class="hljs-comment">//记录dfs序</span><br>		rk[tim]=x;<span class="hljs-comment">//记录访问节点的顺序,即dfn的反函数</span><br>		top[x]=t;<span class="hljs-comment">//注意这里,top是在树外的</span><br>		w[tim]=val[x];<span class="hljs-comment">//将x结点权值存到对应的时间戳</span><br>		<span class="hljs-keyword">if</span>(!son[x])<span class="hljs-comment">//没有儿子</span><br>			<span class="hljs-keyword">return</span>;<br>		<span class="hljs-built_in">dfs2</span>(son[x],t);<span class="hljs-comment">//继续处理重儿子</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];~i;i=e[i].nex)<span class="hljs-comment">//处理其他儿子</span><br>			<span class="hljs-keyword">if</span>(e[i].v!=father[x]&amp;&amp;e[i].v!=son[x])<br>				<span class="hljs-built_in">dfs2</span>(e[i].v,e[i].v);<span class="hljs-comment">//开始另一条重链</span><br>	&#125;<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">while</span>(top[x]!=top[y])<br>		&#123;<br>			<span class="hljs-keyword">if</span>(depth[top[x]]&lt;depth[top[y]])<br>				<span class="hljs-built_in">swap</span>(x,y);<br>			x=father[top[x]];<br>		&#125;<br>		<span class="hljs-keyword">return</span> (depth[x]&gt;depth[y])?y:x;<br>	&#125;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><span class="hljs-comment">//线段树按dfs序维护树上路径权值部分</span><br>	&#123;<br>		ll val,Max,lazy;<br>	&#125; tree[maxn&lt;&lt;<span class="hljs-number">2</span>];<br>	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span></span><br><span class="hljs-function">	</span>&#123;<br>		tree[root].val=tree[root&lt;&lt;<span class="hljs-number">1</span>].val+tree[root&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].val;<br>		tree[root].Max=<span class="hljs-built_in">max</span>(tree[root&lt;&lt;<span class="hljs-number">1</span>].Max,tree[root&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].Max);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> root,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">	</span>&#123;<br>		tree[root].lazy=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">if</span>(l==r)<span class="hljs-comment">//注意这里是l</span><br>			tree[root].val=tree[root].Max=w[l];<span class="hljs-comment">//按时间戳顺序的数组</span><br>		<span class="hljs-keyword">else</span>&#123;<br>			<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>			<span class="hljs-built_in">build</span>(root&lt;&lt;<span class="hljs-number">1</span>,l,mid);<br>			<span class="hljs-built_in">build</span>(root&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br>			<span class="hljs-built_in">pushup</span>(root);<br>		&#125;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> root,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">if</span>(tree[root].lazy)<br>		&#123;<br>			<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>			tree[root&lt;&lt;<span class="hljs-number">1</span>].val=tree[root&lt;&lt;<span class="hljs-number">1</span>].val+tree[root].lazy*(mid-l+<span class="hljs-number">1</span>);<br>			tree[root&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].val=tree[root&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].val+tree[root].lazy*(r-mid);<br>			tree[root&lt;&lt;<span class="hljs-number">1</span>].Max+=tree[root].lazy;<span class="hljs-comment">//子节点最大值也要+更新值</span><br>			tree[root&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].Max+=tree[root].lazy;<br>			tree[root&lt;&lt;<span class="hljs-number">1</span>].lazy+=tree[root].lazy;<br>			tree[root&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].lazy+=tree[root].lazy;<br>			tree[root].lazy=<span class="hljs-number">0</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> root,<span class="hljs-type">int</span> nst,<span class="hljs-type">int</span> ned,<span class="hljs-type">int</span> ust,<span class="hljs-type">int</span> ued,ll num)</span></span><br><span class="hljs-function">	</span>&#123;<span class="hljs-comment">//区间更新</span><br>		<span class="hljs-keyword">if</span>(ned&lt;ust||ued&lt;nst)<br>			<span class="hljs-keyword">return</span>;<br>		<span class="hljs-keyword">if</span>(ust&lt;=nst&amp;&amp;ued&gt;=ned)<br>		&#123;<br>			tree[root].val=tree[root].val+(ned-nst+<span class="hljs-number">1</span>)*num;<br>			tree[root].Max+=num;<br>			tree[root].lazy+=num;<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		<span class="hljs-built_in">pushdown</span>(root,nst,ned);<br>		<span class="hljs-type">int</span> mid=(nst+ned)&gt;&gt;<span class="hljs-number">1</span>;<br>		<span class="hljs-built_in">modify</span>(root&lt;&lt;<span class="hljs-number">1</span>,nst,mid,ust,ued,num);<br>		<span class="hljs-built_in">modify</span>(root&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,ned,ust,ued,num);<br>		<span class="hljs-built_in">pushup</span>(root);<br>	&#125;<br>	<span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> root,<span class="hljs-type">int</span> nst,<span class="hljs-type">int</span> ned,<span class="hljs-type">int</span> qst,<span class="hljs-type">int</span> qed)</span></span><br><span class="hljs-function">	</span>&#123;<span class="hljs-comment">//查询区间和</span><br>		<span class="hljs-keyword">if</span>(ned&lt;qst||qed&lt;nst)<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">if</span>(qst&lt;=nst&amp;&amp;ned&lt;=qed)<br>			<span class="hljs-keyword">return</span> tree[root].val;<br>		<span class="hljs-built_in">pushdown</span>(root,nst,ned);<br>		<span class="hljs-type">int</span> mid=(nst+ned)&gt;&gt;<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(root&lt;&lt;<span class="hljs-number">1</span>,nst,mid,qst,qed)+<span class="hljs-built_in">query</span>(root&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,ned,qst,qed);<br>	&#125;<br>	<span class="hljs-function">ll <span class="hljs-title">qmax</span><span class="hljs-params">(<span class="hljs-type">int</span> root,<span class="hljs-type">int</span> nst,<span class="hljs-type">int</span> ned,<span class="hljs-type">int</span> qst,<span class="hljs-type">int</span> qed)</span></span><br><span class="hljs-function">	</span>&#123;<span class="hljs-comment">//查询区间和</span><br>		<span class="hljs-keyword">if</span>(ned&lt;qst||qed&lt;nst)<br>			<span class="hljs-keyword">return</span> LLONG_MIN;<br>		<span class="hljs-keyword">if</span>(qst&lt;=nst&amp;&amp;ned&lt;=qed)<br>			<span class="hljs-keyword">return</span> tree[root].Max;<br>		<span class="hljs-built_in">pushdown</span>(root,nst,ned);<br>		<span class="hljs-type">int</span> mid=(nst+ned)&gt;&gt;<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">qmax</span>(root&lt;&lt;<span class="hljs-number">1</span>,nst,mid,qst,qed),<span class="hljs-built_in">qmax</span>(root&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,ned,qst,qed));<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">mson</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> n,ll addnum)</span></span><br><span class="hljs-function">	</span>&#123;<span class="hljs-comment">//将以x为根的子树全部加上一个数</span><br>		<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,dfn[x],dfn[x]+siz[x]<span class="hljs-number">-1</span>,addnum);<span class="hljs-comment">//子树节点编号是连续的</span><br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">sonsum</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">	</span>&#123;<span class="hljs-comment">//查询以x为根子树权值和</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,dfn[x],dfn[x]+siz[x]<span class="hljs-number">-1</span>);<span class="hljs-comment">//同上</span><br>	&#125;<br>	<span class="hljs-function">ll <span class="hljs-title">sonmax</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">qmax</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,dfn[x],dfn[x]+siz[x]<span class="hljs-number">-1</span>);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mchain</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> n,ll addnum)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">while</span>(top[x]!=top[y])<span class="hljs-comment">//不在同一条链上时</span><br>		&#123;<br>			<span class="hljs-keyword">if</span>(depth[top[x]]&lt;depth[top[y]])<br>				<span class="hljs-built_in">swap</span>(x,y);<span class="hljs-comment">//保证x所在链顶部更低</span><br>			<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,dfn[top[x]],dfn[x],addnum);<span class="hljs-comment">//更新顶部节点较低的重链(顶部节点到当前点部分)</span><br>			x=father[top[x]];<span class="hljs-comment">//跳到链顶节点的父节点</span><br>		&#125;<br>		<span class="hljs-keyword">if</span>(depth[x]&gt;depth[y])<span class="hljs-comment">//直到最后在同一条重链上</span><br>			<span class="hljs-built_in">swap</span>(x,y);<span class="hljs-comment">//此时保证x节点在y上面</span><br>		<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,dfn[x],dfn[y],addnum);<br>	&#125;<br>	<span class="hljs-function">ll <span class="hljs-title">chainsum</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">	</span>&#123;<br>		ll ret=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">while</span>(top[x]!=top[y])<br>		&#123;<br>			<span class="hljs-keyword">if</span>(depth[top[x]]&lt;depth[top[y]])<br>				<span class="hljs-built_in">swap</span>(x,y);<br>			ret+=<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,dfn[top[x]],dfn[x]);<br>			x=father[top[x]];<br>		&#125;<br>		<span class="hljs-keyword">if</span>(depth[x]&gt;depth[y])<br>			<span class="hljs-built_in">swap</span>(x,y);<br>		<span class="hljs-keyword">return</span> ret+<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,dfn[x],dfn[y]);<br>	&#125;<br>	<span class="hljs-function">ll <span class="hljs-title">chainmax</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">	</span>&#123;<br>		ll ret=LLONG_MIN;<br>		<span class="hljs-keyword">while</span>(top[x]!=top[y])<br>		&#123;<br>			<span class="hljs-keyword">if</span>(depth[top[x]]&lt;depth[top[y]])<br>				<span class="hljs-built_in">swap</span>(x,y);<br>			ret=<span class="hljs-built_in">max</span>(ret,<span class="hljs-built_in">qmax</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,dfn[top[x]],dfn[x]));<br>			x=father[top[x]];<br>		&#125;<br>		<span class="hljs-keyword">if</span>(depth[x]&gt;depth[y])<br>			<span class="hljs-built_in">swap</span>(x,y);<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(ret,<span class="hljs-built_in">qmax</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,dfn[x],dfn[y]));<br>	&#125;<br>&#125;<br></code></pre>



<h4 id="P3384-树链剖分"><a href="#P3384-树链剖分" class="headerlink" title="P3384 树链剖分 "></a><a target="_blank" rel="noopener" href="https://www.luogu.org/problem/P3384">P3384 树链剖分 </a></h4><pre class="highlight"><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">100005</span>;<br><span class="hljs-type">int</span> mod=<span class="hljs-number">100000007</span>;<br><span class="hljs-type">int</span> head[maxn],cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><br>&#123;<br>	<span class="hljs-type">int</span> v,nex;<br>&#125; e[maxn&lt;&lt;<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> father[maxn],son[maxn];<span class="hljs-comment">//父节点,重儿子节点</span><br><span class="hljs-type">int</span> depth[maxn],siz[maxn],top[maxn];<span class="hljs-comment">//深度,子树大小,节点所在重链的顶部节点</span><br><span class="hljs-type">int</span> tim=<span class="hljs-number">0</span>,dfn[maxn],rk[maxn],w[maxn];<span class="hljs-comment">//计数器,时间戳(节点编号),访问顺序</span><br><span class="hljs-type">int</span> val[maxn];<span class="hljs-comment">//给定的每个节点的权值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>	e[++cnt].v=v;<br>	e[cnt].nex=head[u];<br>	head[u]=cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>	father[x]=fa;<br>	depth[x]=depth[fa]+<span class="hljs-number">1</span>;<br>	siz[x]=<span class="hljs-number">1</span>;<br>	<span class="hljs-type">int</span> maxsize=<span class="hljs-number">-1</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];~i;i=e[i].nex)<span class="hljs-comment">//遍历儿子节点</span><br>	&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(v==fa)<br>			<span class="hljs-keyword">continue</span>;<br>		<span class="hljs-built_in">dfs1</span>(v,x);<br>		siz[x]+=siz[v];<span class="hljs-comment">//加上儿子的子树大小</span><br>		<span class="hljs-keyword">if</span>(siz[v]&gt;maxsize)<br>		&#123;<br>			maxsize=siz[v];<br>			son[x]=v;<span class="hljs-comment">//记录重儿子</span><br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> t)</span><span class="hljs-comment">//当前节点与重链顶节点</span></span><br><span class="hljs-function"></span>&#123;<br>	top[x]=t;<span class="hljs-comment">//记录该节点所在重链的顶部节点</span><br>	dfn[x]=++tim;<span class="hljs-comment">//记录该节点的访问时间(给节点编号,方便线段树操作)</span><br>	rk[tim]=x;<span class="hljs-comment">//记录访问节点的顺序</span><br>	w[tim]=val[x];<span class="hljs-comment">//将x结点权值存到对应的时间戳</span><br>	<span class="hljs-keyword">if</span>(!son[x])<br>		<span class="hljs-keyword">return</span>;<span class="hljs-comment">//没有儿子</span><br>	<span class="hljs-built_in">dfs2</span>(son[x],t);<span class="hljs-comment">//继续处理重儿子</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];~i;i=e[i].nex)<br>	&#123;<span class="hljs-comment">//处理其他儿子</span><br>		<span class="hljs-keyword">if</span>(e[i].v!=son[x]&amp;&amp;e[i].v!=father[x])<br>			<span class="hljs-built_in">dfs2</span>(e[i].v,e[i].v);<span class="hljs-comment">//开始另一条重链</span><br>	&#125;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br>	<span class="hljs-type">int</span> val,lazy;<br>&#125; tree[maxn&lt;&lt;<span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span></span><br><span class="hljs-function"></span>&#123;<br>	tree[root].val=(tree[root&lt;&lt;<span class="hljs-number">1</span>].val+tree[root&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].val)%mod;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> root,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>	tree[root].val=tree[root].lazy=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">if</span>(l==r)<span class="hljs-comment">//注意这里是l</span><br>		tree[root].val=w[l]%mod;<span class="hljs-comment">//按时间戳顺序的数组</span><br>	<span class="hljs-keyword">else</span>&#123;<br>		<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>		<span class="hljs-built_in">build</span>(root&lt;&lt;<span class="hljs-number">1</span>,l,mid);<br>		<span class="hljs-built_in">build</span>(root&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br>		<span class="hljs-built_in">pushup</span>(root);<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> root,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span>(tree[root].lazy)<br>	&#123;<br>		<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>		tree[root&lt;&lt;<span class="hljs-number">1</span>].val=(tree[root&lt;&lt;<span class="hljs-number">1</span>].val%mod+(tree[root].lazy%mod*(mid-l+<span class="hljs-number">1</span>))%mod)%mod;<br>		tree[root&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].val=(tree[root&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].val%mod+(tree[root].lazy%mod*(r-mid)%mod))%mod;<br>		tree[root&lt;&lt;<span class="hljs-number">1</span>].lazy=(tree[root&lt;&lt;<span class="hljs-number">1</span>].lazy%mod+tree[root].lazy%mod)%mod;<br>		tree[root&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].lazy=(tree[root&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].lazy%mod+tree[root].lazy%mod)%mod;<br>		tree[root].lazy=<span class="hljs-number">0</span>;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> root,<span class="hljs-type">int</span> nst,<span class="hljs-type">int</span> ned,<span class="hljs-type">int</span> ust,<span class="hljs-type">int</span> ued,<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span>(ned&lt;ust||ued&lt;nst)<br>		<span class="hljs-keyword">return</span>;<br>	<span class="hljs-keyword">if</span>(ust&lt;=nst&amp;&amp;ued&gt;=ned)<br>	&#123;<br>		tree[root].lazy=(tree[root].lazy%mod+num%mod)%mod;<br>		tree[root].val=(tree[root].val%mod+((ned-nst+<span class="hljs-number">1</span>)%mod*(num%mod))%mod)%mod;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-built_in">pushdown</span>(root,nst,ned);<br>	<span class="hljs-type">int</span> mid=(nst+ned)&gt;&gt;<span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">modify</span>(root&lt;&lt;<span class="hljs-number">1</span>,nst,mid,ust,ued,num);<br>	<span class="hljs-built_in">modify</span>(root&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,ned,ust,ued,num);<br>	<span class="hljs-built_in">pushup</span>(root);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> root,<span class="hljs-type">int</span> nst,<span class="hljs-type">int</span> ned,<span class="hljs-type">int</span> qst,<span class="hljs-type">int</span> qed)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span>(ned&lt;qst||qed&lt;nst)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">if</span>(qst&lt;=nst&amp;&amp;qed&gt;=ned)<br>	&#123;<br>		<span class="hljs-keyword">return</span> tree[root].val%mod;<br>	&#125;<br>	<span class="hljs-built_in">pushdown</span>(root,nst,ned);<br>	<span class="hljs-type">int</span> mid=(nst+ned)&gt;&gt;<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">return</span> (<span class="hljs-built_in">query</span>(root&lt;&lt;<span class="hljs-number">1</span>,nst,mid,qst,qed)+<span class="hljs-built_in">query</span>(root&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,ned,qst,qed))%mod;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">mson</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> addnum)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//将以x为根的子树全部加上一个数</span><br>	<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,dfn[x],dfn[x]+siz[x]<span class="hljs-number">-1</span>,addnum);<span class="hljs-comment">//子树节点编号是连续的</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">qson</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,dfn[x],dfn[x]+siz[x]<span class="hljs-number">-1</span>)%mod;<span class="hljs-comment">//同上</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mchain</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> addnum)</span></span><br><span class="hljs-function"></span>&#123;<br>	addnum%=mod;<br>	<span class="hljs-keyword">while</span>(top[x]!=top[y])<span class="hljs-comment">//不在同一条链上时</span><br>	&#123;<br>		<span class="hljs-keyword">if</span>(depth[top[x]]&lt;depth[top[y]])<br>			<span class="hljs-built_in">swap</span>(x,y);<span class="hljs-comment">//保证x所在链顶部更低</span><br>		<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,dfn[top[x]],dfn[x],addnum);<span class="hljs-comment">//更新顶部节点较低的重链(顶部节点到当前点部分)</span><br>		x=father[top[x]];<span class="hljs-comment">//跳到链顶节点的父节点</span><br>	&#125;<br>	<span class="hljs-keyword">if</span>(depth[x]&gt;depth[y])<span class="hljs-comment">//直到最后在同一条重链上</span><br>		<span class="hljs-built_in">swap</span>(x,y);<span class="hljs-comment">//此时保证x节点在y上面</span><br>	<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,dfn[x],dfn[y],addnum);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qchain</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> ret=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(top[x]!=top[y])<br>	&#123;<br>		<span class="hljs-keyword">if</span>(depth[top[x]]&lt;depth[top[y]])<br>			<span class="hljs-built_in">swap</span>(x,y);<br>		ret=(ret+<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,dfn[top[x]],dfn[x]))%mod;<br>		x=father[top[x]];<br>	&#125;<br>	<span class="hljs-keyword">if</span>(depth[x]&gt;depth[y])<br>		<span class="hljs-built_in">swap</span>(x,y);<br>	<span class="hljs-keyword">return</span> (ret+<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,dfn[x],dfn[y]))%mod;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//	freopen(&quot;P3384.in&quot;,&quot;r&quot;,stdin);</span><br>	<span class="hljs-type">int</span> n,m,p,r;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;r,&amp;mod);<br>	<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;val[i]);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br>	&#123;<br>		<span class="hljs-type">int</span> u,v;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);<br>		<span class="hljs-built_in">add</span>(u,v);<br>		<span class="hljs-built_in">add</span>(v,u);<br>	&#125;<br>	<span class="hljs-built_in">dfs1</span>(r,r);<br>	<span class="hljs-built_in">dfs2</span>(r,r);<br>	<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br>	<span class="hljs-keyword">while</span>(m--)<br>	&#123;<br>		<span class="hljs-type">int</span> ope,x,y,z;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;ope);<br>		<span class="hljs-keyword">if</span>(ope==<span class="hljs-number">1</span>)<br>		&#123;<span class="hljs-comment">//链x-&gt;y修改,全部加上z</span><br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);<br>			<span class="hljs-built_in">mchain</span>(x,y,n,z);<br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">2</span>)<br>		&#123;<span class="hljs-comment">//链x-&gt;y查询</span><br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">qchain</span>(x,y,n));<br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">3</span>)<br>		&#123;<span class="hljs-comment">//x子树修改</span><br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;z);<br>			<span class="hljs-built_in">mson</span>(x,n,z);<br>		&#125;<br>		<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//x子树查询</span><br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">qson</span>(x,n));<br>		&#125;<br>	&#125;<br><span class="hljs-comment">//	for(int i=1;i&lt;=n;i++)</span><br><span class="hljs-comment">//		printf(&quot;%d:%d\n&quot;,i,tree[i].val);</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *功能：</span><br><span class="hljs-comment"> *1.更新/查询某个节点子树的权值</span><br><span class="hljs-comment"> *2.更新/查询树上两个节点间所有点的权值</span><br><span class="hljs-comment"> *性质：</span><br><span class="hljs-comment"> *1.子树的时间戳一定全部小于父节点，并且连续</span><br><span class="hljs-comment"> *2.任何一条路径都是由重链的一部分与重链间的叶子节点构成</span><br><span class="hljs-comment"> *3.任何父节点都一定在一条重链上</span><br><span class="hljs-comment">*/</span><br></code></pre>

<h3 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h3><h4 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h4><ul>
<li>也叫树的质心。找到一个点,其所有的子树中最大的子树节点数最少,那么这个点就是这棵树的重心,删去重心后，生成的多棵树尽可能平衡。</li>
</ul>
<h4 id="流程-3"><a href="#流程-3" class="headerlink" title="流程"></a>流程</h4><ol>
<li>找出当前树的重心<ul>
<li>因为分治步骤二需要将sum赋值为当前树大小(siz[v])，所以getrt要跑两遍</li>
</ul>
</li>
<li>处理经过中心的路径<ul>
<li>点分治运算的核心，经常会出现变形</li>
</ul>
</li>
<li>删除树的重心</li>
<li>对新得到的子树重复上述步骤</li>
</ol>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>一棵n节点的树，询问树上距离为k的点对是否存在。离线操作。</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">10005</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxk=<span class="hljs-number">10000005</span>;<br><span class="hljs-type">int</span> tot=<span class="hljs-number">0</span>,head[maxn];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><br>&#123;<br>	<span class="hljs-type">int</span> v,nex,w;<br>&#125; e[maxn&lt;&lt;<span class="hljs-number">1</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,ll w)</span></span><br><span class="hljs-function"></span>&#123;<br>	e[++tot].v=v;<br>	e[tot].nex=head[u];<br>	e[tot].w=w;<br>	head[u]=tot;<br>&#125;<br><span class="hljs-type">int</span> n,m,root,sum=<span class="hljs-number">0</span>;<span class="hljs-comment">//重心,sum当前大小</span><br><span class="hljs-type">int</span> siz[maxn],maxp[maxn];<br><span class="hljs-type">bool</span> vis[maxn];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//DFS找重心</span><br>	siz[x]=<span class="hljs-number">1</span>,maxp[x]=<span class="hljs-number">0</span>;<span class="hljs-comment">//maxp为最大子树大小</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];~i;i=e[i].nex)<br>	&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(v==fa||vis[v])<br>			<span class="hljs-keyword">continue</span>;<br>		<span class="hljs-built_in">getrt</span>(v,x);<br>		siz[x]+=siz[v];<br>		<span class="hljs-keyword">if</span>(siz[v]&gt;maxp[x])<br>			maxp[x]=siz[v];<span class="hljs-comment">//记录下面的最大子树大小</span><br>	&#125;<span class="hljs-comment">//无根树,sum-siz[x]为以x的父节点为根的大小</span><br>	<span class="hljs-comment">//在以自身为根节点的子树大小和以x的父节点为根的大小中取较大的</span><br>	maxp[x]=<span class="hljs-built_in">max</span>(maxp[x],sum-siz[x]);<span class="hljs-comment">//sum为整棵树的大小</span><br>	<span class="hljs-keyword">if</span>(maxp[x]&lt;maxp[root])<br>		root=x;<span class="hljs-comment">//最大子树最小的点为重心</span><br>&#125;<br><span class="hljs-type">int</span> dist[maxn],tmp[maxn],cnt=<span class="hljs-number">0</span>;<span class="hljs-comment">//cnt计数器</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getdist</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//DFS求各点到root的距离,记录在tmp中</span><br>	tmp[++cnt]=dist[x];<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];~i;i=e[i].nex)<br>	&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(v==fa||vis[v])<br>			<span class="hljs-keyword">continue</span>;<br>		dist[v]=dist[x]+e[i].w;<br>		<span class="hljs-built_in">getdist</span>(v,x);<br>	&#125;<br>&#125;<br><span class="hljs-type">int</span> q[<span class="hljs-number">105</span>];<span class="hljs-comment">//q记录询问距离</span><br><span class="hljs-type">bool</span> jud[maxk],ans[<span class="hljs-number">105</span>];<span class="hljs-comment">//存放之前子树中的存在路径长度,ans判断k是否存在</span><br>queue&lt;<span class="hljs-type">int</span>&gt; QwQ;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//处理经过根节点x的路径</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];~i;i=e[i].nex)<br>	&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(vis[v])<span class="hljs-comment">//该点已经被去掉</span><br>			<span class="hljs-keyword">continue</span>;<br>		cnt=<span class="hljs-number">0</span>;<br>		dist[v]=e[i].w;<span class="hljs-comment">//设置root与儿子的距离</span><br>		<span class="hljs-built_in">getdist</span>(v,x);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt;j++)<span class="hljs-comment">//遍历该子树上的距离</span><br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=m;k++)<span class="hljs-comment">//遍历询问</span><br>				<span class="hljs-keyword">if</span>(q[k]&gt;=tmp[j])<span class="hljs-comment">//有拼出来的可能性</span><br>					ans[k]|=jud[q[k]-tmp[j]];<span class="hljs-comment">//可以用之前以x为顶的距离拼起来</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt;j++)<span class="hljs-comment">//将这棵子树的距离存起来</span><br>		&#123;<span class="hljs-comment">//供之后的以x为节点的子树拼路径使用</span><br>			QwQ.<span class="hljs-built_in">push</span>(tmp[j]);<br>			jud[tmp[j]]=<span class="hljs-number">1</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">while</span>(!QwQ.<span class="hljs-built_in">empty</span>())<br>	&#123;<br>		jud[QwQ.<span class="hljs-built_in">front</span>()]=<span class="hljs-number">0</span>;<br>		QwQ.<span class="hljs-built_in">pop</span>();<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>	vis[x]=jud[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//去掉根节点x</span><br>	<span class="hljs-built_in">solve</span>(x);<span class="hljs-comment">//处理所有经过x的路径</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];~i;i=e[i].nex)<br>	&#123;<br>		<span class="hljs-type">int</span> v=e[i].v;<br>		<span class="hljs-keyword">if</span>(vis[v])<br>			<span class="hljs-keyword">continue</span>;<br>		maxp[root=<span class="hljs-number">0</span>]=sum=siz[v];<span class="hljs-comment">//重心置为0,maxp[0]置为最大值(所以要重新DFS计算siz)</span><br>		<span class="hljs-built_in">getrt</span>(v,<span class="hljs-number">0</span>);<span class="hljs-comment">//在以v为根的子树上找重心</span><br>		<span class="hljs-built_in">getrt</span>(root,<span class="hljs-number">0</span>);<span class="hljs-comment">//处理出以v为根的siz数组</span><br>		<span class="hljs-built_in">divide</span>(root);<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> k,u,v;<br>	ll w;<br>	<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>	cin&gt;&gt;n&gt;&gt;m;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br>	&#123;<span class="hljs-comment">//点u到点v距离为w</span><br>		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>		<span class="hljs-built_in">add</span>(u,v,w);<br>		<span class="hljs-built_in">add</span>(v,u,w);<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>		cin&gt;&gt;q[i];<br>	maxp[<span class="hljs-number">0</span>]=sum=n;<span class="hljs-comment">//置为最大值</span><br>	<span class="hljs-built_in">getrt</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>	<span class="hljs-built_in">getrt</span>(root,<span class="hljs-number">0</span>);<span class="hljs-comment">//更新以重心为根的siz数组</span><br>	<span class="hljs-built_in">divide</span>(root);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>		cout&lt;&lt;(ans[i]?<span class="hljs-string">&quot;AYE&quot;</span>:<span class="hljs-string">&quot;NAY&quot;</span>)&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre>



<h3 id="树上启发式合并（DSU-on-tree）"><a href="#树上启发式合并（DSU-on-tree）" class="headerlink" title="树上启发式合并（DSU on tree）"></a>树上启发式合并（DSU on tree）</h3><p>解决<strong>离线子树查询</strong>问题，即统计树上一个节点的子树中具有某种特征的节点数。</p>
<p>一般也可以使用DFS序莫队或DFS序主席树做。</p>
<p>时间复杂度$O(nlogn)$，空间复杂度$O(n)$。</p>
<h4 id="流程-4"><a href="#流程-4" class="headerlink" title="流程"></a>流程</h4><ol>
<li>先用dfs处理出重儿子</li>
<li>使用DFS处理各子树信息，设当前子树根节点为x<ul>
<li><strong>遍历</strong>x的轻儿子，计算轻儿子子树贡献，<strong>记录到ans数组</strong>，信息不做保留。</li>
<li>处理x的重儿子子树贡献，<strong>记录到ans数组</strong>，并保留。</li>
<li>暴力统计节点x及所有轻儿子子树贡献，与x的重儿子子树贡献汇总，一同<strong>回溯</strong>到上一级，以便处理出以x节点的父节点为根的子树的贡献。</li>
</ul>
</li>
</ol>
<h3 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h3><p><del>二分图如果不考虑复杂度的话，可以用网络流来做。</del></p>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul>
<li>最大匹配：二分图中边集的数目最大的匹配。</li>
<li>点覆盖：图$G&#x3D;(V,E)$中的一个点覆盖为一个集合$S⊆V$使得<strong>每条边至少有一个端点</strong>在$S$中。</li>
<li>最小点覆盖：点个数最少的$S$集合。</li>
<li>最小边覆盖：用最少不相交简单路径覆盖DAG所有顶点。</li>
<li>最小点权覆盖：覆盖每个节点都需要一定代价，覆盖所有边总代价最小的点集。</li>
<li>最大独立集：在点集$V$中选出$M$个点，$M$中点与点两两无边，并使$M$最大。</li>
</ul>
<h4 id="常见二分图结论"><a href="#常见二分图结论" class="headerlink" title="常见二分图结论"></a>常见二分图结论</h4><ul>
<li><strong>最小点覆盖&#x3D;二分图最大匹配</strong></li>
<li>最小边覆盖&#x3D;顶点数-最小顶点覆盖（二分图最大匹配）</li>
<li>最大独立集&#x3D;顶点数-最大匹配数</li>
<li>所有回路长度均为偶数</li>
</ul>
<h4 id="适用任意图的结论"><a href="#适用任意图的结论" class="headerlink" title="适用任意图的结论"></a>适用任意图的结论</h4><ul>
<li><p>对于不存在孤立点的图，最大匹配+最小边覆盖&#x3D;顶点数</p>
</li>
<li><p>最大独立集+最小顶点覆盖&#x3D;顶点数</p>
</li>
</ul>
<h4 id="二分图判定（黑白染色法）"><a href="#二分图判定（黑白染色法）" class="headerlink" title="二分图判定（黑白染色法）"></a>二分图判定（黑白染色法）</h4><p>A、B集合分别染成不同颜色（由边链接的两节点颜色一定不同）</p>
<p>A集合中选取一个起始节点，将邻接的点染成与其不同的颜色，如果邻接的点有相同颜色的，则说明不是二分图</p>
<h4 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h4><h5 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h5><p>时间复杂度O(nm)，有重边时使用邻接矩阵？</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">205</span>;<span class="hljs-comment">//在主函数内向关系图G中加边</span><br>vector&lt;<span class="hljs-type">int</span>&gt; G[maxn];<span class="hljs-comment">//注意使用前clear()</span><br><span class="hljs-type">int</span> linker[maxn];<br><span class="hljs-type">bool</span> used[maxn];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-comment">//</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;v:G[x])<br>		<span class="hljs-keyword">if</span>(!used[v])<span class="hljs-comment">//在右边找</span><br>		&#123;<br>			used[v]=<span class="hljs-number">1</span>;<br>			<span class="hljs-keyword">if</span>(!linker[v]||<span class="hljs-built_in">dfs</span>(linker[v]))<br>			&#123;<br>				linker[v]=x;<span class="hljs-comment">//记录右边v号匹配</span><br>				<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>			&#125;<br>		&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//未找到增广路</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hungry</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">memset</span>(linker,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(linker));<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//遍历左面</span><br>	&#123;<br>		<span class="hljs-built_in">memset</span>(used,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(used));<br>		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(i))<span class="hljs-comment">//能找到增广路</span><br>			ans++;<br>	&#125;<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre>



<h4 id="KM算法"><a href="#KM算法" class="headerlink" title="KM算法"></a>KM算法</h4><ul>
<li>二分图最佳完美匹配：带权二分图，求一种<strong>完备匹配</strong>方案，使得所有<strong>匹配边的权和最大</strong>。</li>
</ul>
<h5 id="BFS，复杂度稳的一批"><a href="#BFS，复杂度稳的一批" class="headerlink" title="BFS，复杂度稳的一批"></a>BFS，复杂度稳的一批</h5><p>复杂度$O(n^3)$，使用时清空w数组，并且按照关系为w赋值，调用KM(n)即可得到匹配边权值和。</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1005</span>;<br><span class="hljs-type">int</span> w[maxn][maxn];<span class="hljs-comment">//二分图间的权值</span><br><span class="hljs-type">int</span> lx[maxn],ly[maxn];<br><span class="hljs-type">int</span> linker[maxn];<span class="hljs-comment">//B图匹配到的A图节点</span><br><span class="hljs-type">int</span> slack[maxn];<br><span class="hljs-type">bool</span> visy[maxn];<span class="hljs-comment">//记录每一轮B图匹配过</span><br><span class="hljs-type">int</span> pre[maxn];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x,y=<span class="hljs-number">0</span>,yy=<span class="hljs-number">0</span>,delta;<br>    <span class="hljs-built_in">memset</span>(pre,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(pre));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>		slack[i]=INF;<br>    linker[y]=k;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>	&#123;<br>        x=linker[y];<br>        delta=INF;<br>        visy[y]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>		&#123;<br>            <span class="hljs-keyword">if</span>(!visy[i])<br>            &#123;<br>                <span class="hljs-keyword">if</span>(slack[i]&gt;lx[x]+ly[i]-w[x][i])<br>                &#123;<br>                    slack[i]=lx[x]+ly[i]-w[x][i];<br>                    pre[i]=y;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(slack[i]&lt;delta)<br>					delta=slack[i],yy=i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>( visy[i] )<br>				lx[linker[i]]-=delta,ly[i]+=delta;<br>            <span class="hljs-keyword">else</span><br>				slack[i]-=delta;<br>        &#125;<br>        y=yy;<br>        <span class="hljs-keyword">if</span>(linker[y]==<span class="hljs-number">-1</span>)<br>			<span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(y)<br>		linker[y]=linker[pre[y]],y=pre[y];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">KM</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(lx,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(lx));<br>    <span class="hljs-built_in">memset</span>(ly,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(ly));<br>    <span class="hljs-built_in">memset</span>(linker,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(linker));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>	&#123;<br>        <span class="hljs-built_in">memset</span>(visy,<span class="hljs-literal">false</span>,<span class="hljs-built_in">sizeof</span>(visy));<br>        <span class="hljs-built_in">bfs</span>(i,n);<br>    &#125;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>	&#123;<br>		<span class="hljs-keyword">if</span>(linker[i]!=<span class="hljs-number">-1</span>)<br>			ans+=w[linker[i]][i];<br>	&#125;<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre>

<h5 id="左右数目不等的模板"><a href="#左右数目不等的模板" class="headerlink" title="左右数目不等的模板"></a>左右数目不等的模板</h5><pre class="highlight"><code class="hljs cpp"><span class="hljs-type">int</span> wx[maxn],wy[maxn],match[maxn];<br><span class="hljs-type">int</span> mp[maxn][maxn],slack[maxn],pre[maxn];<br><span class="hljs-type">bool</span> viy[maxn];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> py=<span class="hljs-number">0</span>,px,yy=<span class="hljs-number">0</span>,delta;<br>	match[py]=k;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)pre[i]=<span class="hljs-number">0</span>,slack[i]=inf;<br>	<span class="hljs-keyword">do</span><br>    &#123;<br>		px=match[py],delta=inf,viy[py]=<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!viy[i])<br>            &#123;<br>                <span class="hljs-keyword">if</span>(wx[px]+wy[i]-mp[px][i]&lt;slack[i])slack[i]=wx[px]+wy[i]-mp[px][i],pre[i]=py;<br>                <span class="hljs-keyword">if</span>(slack[i]&lt;delta)delta=slack[i],yy=i;<br>            &#125;<br>        &#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(viy[i])wx[match[i]]-=delta,wy[i]+=delta;<br>			<span class="hljs-keyword">else</span> slack[i]-=delta;<br>        &#125;<br>		py=yy;<br>	&#125;<span class="hljs-keyword">while</span>(match[py]!=<span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">while</span>(py)match[py]=match[pre[py]],py=pre[py];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">km</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//n&gt;=m,mp[m][n]这样输入匹配权值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>		wy[i]=<span class="hljs-number">0</span>,match[i]=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>		wx[i]=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>			wx[i]=<span class="hljs-built_in">max</span>(wx[i],mp[i][j]);<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)<br>		<span class="hljs-built_in">memset</span>(viy,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(viy)),<span class="hljs-built_in">bfs</span>(i,n,m);<br>	<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>		ans+=wx[match[i]]+wy[i];<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre>



<h5 id="CSL的写法"><a href="#CSL的写法" class="headerlink" title="CSL的写法"></a>CSL的写法</h5>  <pre class="highlight"><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">305</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-comment">//KM算法:带权的二分图中寻找*权值和最大*的完备匹配</span><br><span class="hljs-type">int</span> cost[maxn][maxn];<span class="hljs-comment">//A[i]连接B[j]的权值</span><br><span class="hljs-type">int</span> lx[maxn], ly[maxn];<br><span class="hljs-type">int</span> match[maxn], slack[maxn];<span class="hljs-comment">//B[i]匹配到的A,</span><br><span class="hljs-type">int</span> previous[maxn];<br><span class="hljs-type">bool</span> vy[maxn];<span class="hljs-comment">//匹配过</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">augment</span><span class="hljs-params">(<span class="hljs-type">int</span> root,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">fill</span>(vy + <span class="hljs-number">1</span>, vy + n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br>	<span class="hljs-built_in">fill</span>(slack + <span class="hljs-number">1</span>, slack + n + <span class="hljs-number">1</span>, INF);<br>	<span class="hljs-type">int</span> py;<br>	match[py = <span class="hljs-number">0</span>] = root;<br>	<span class="hljs-keyword">do</span><br>	&#123;<br>		vy[py] = <span class="hljs-literal">true</span>;<br>		<span class="hljs-type">int</span> x = match[py], yy;<br>		<span class="hljs-type">int</span> delta = INF;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">1</span>; y &lt;= n; y++)<br>		&#123;<br>			<span class="hljs-keyword">if</span> (!vy[y])<br>			&#123;<br>				<span class="hljs-keyword">if</span> (lx[x] + ly[y] - cost[x][y] &lt; slack[y])<br>					slack[y] = lx[x] + ly[y] - cost[x][y], previous[y] = py;<br>				<span class="hljs-keyword">if</span> (slack[y] &lt; delta)<br>					delta = slack[y], yy = y;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt;= n; y++)<br>		&#123;<br>			<span class="hljs-keyword">if</span> (vy[y])<br>				lx[match[y]] -= delta, ly[y] += delta;<br>			<span class="hljs-keyword">else</span><br>				slack[y] -= delta;<br>		&#125;<br>		py = yy;<br>	&#125;<br>	<span class="hljs-keyword">while</span>(match[py] != <span class="hljs-number">-1</span>);<br>	<span class="hljs-keyword">do</span><br>	&#123;<br>		<span class="hljs-type">int</span> pre = previous[py];<br>		match[py] = match[pre], py = pre;<br>	&#125; <span class="hljs-keyword">while</span> (py);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">KM</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>	&#123;<br>		lx[i] = ly[i] = <span class="hljs-number">0</span>;<br>		match[i] = <span class="hljs-number">-1</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>			lx[i] = <span class="hljs-built_in">max</span>(lx[i], cost[i][j]);<br>	&#125;<br>	<span class="hljs-type">int</span> answer = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> root = <span class="hljs-number">1</span>; root &lt;= n; root++)<br>		<span class="hljs-built_in">augment</span>(root,n);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>		answer += lx[i], answer += ly[i];<br>	<span class="hljs-keyword">return</span> answer;<br>&#125;<br></code></pre>




<h3 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h3><p>注意反向思考，添加新节点进行限流。</p>
<h4 id="模板部分"><a href="#模板部分" class="headerlink" title="模板部分"></a>模板部分</h4><h5 id="dinic"><a href="#dinic" class="headerlink" title="dinic"></a>dinic</h5><pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dinic</span><br>&#123;<span class="hljs-comment">//复杂度O(n^2m)</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span><br>	&#123;<br>		<span class="hljs-type">int</span> from, to, cap, flow;<br>		<span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> f):<br>			<span class="hljs-built_in">from</span>(u), <span class="hljs-built_in">to</span>(v), <span class="hljs-built_in">cap</span>(c), <span class="hljs-built_in">flow</span>(f) &#123;&#125;<br>	&#125;;<br>	<span class="hljs-type">int</span> n, m, s, t; <span class="hljs-comment">//结点数,边数(包括反向弧),源点编号和汇点编号</span><br>	vector&lt;Edge&gt; edges; <span class="hljs-comment">//边表。edge[e]和edge[e^1]互为反向弧</span><br>	vector&lt;<span class="hljs-type">int</span>&gt; G[maxn]; <span class="hljs-comment">//邻接表，G[i][j]表示节点i的第j条边在e数组中的序号</span><br>	<span class="hljs-type">bool</span> vis[maxn]; <span class="hljs-comment">//BFS使用</span><br>	<span class="hljs-type">int</span> d[maxn]; <span class="hljs-comment">//从起点到i的距离</span><br>	<span class="hljs-type">int</span> cur[maxn]; <span class="hljs-comment">//当前弧下标</span><br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">this</span>-&gt;n = n;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) G[i].<span class="hljs-built_in">clear</span>();<br>		edges.<span class="hljs-built_in">clear</span>();<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, <span class="hljs-type">int</span> cap)</span></span><br><span class="hljs-function">	</span>&#123;<br>		edges.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Edge</span>(from, to, cap, <span class="hljs-number">0</span>));<br>		edges.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Edge</span>(to, from, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<span class="hljs-comment">//反向弧,初始容量为0</span><br>		m = edges.<span class="hljs-built_in">size</span>();<br>		G[from].<span class="hljs-built_in">push_back</span>(m - <span class="hljs-number">2</span>);<br>		G[to].<span class="hljs-built_in">push_back</span>(m - <span class="hljs-number">1</span>);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">BFS</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br><span class="hljs-comment">//		memset(d, 0, sizeof(d));</span><br>		queue&lt;<span class="hljs-type">int</span>&gt; q;<br>		q.<span class="hljs-built_in">push</span>(s);<br>		d[s] = <span class="hljs-number">0</span>;<br>		vis[s] = <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>		&#123;<br>			<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>			q.<span class="hljs-built_in">pop</span>();<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G[x].<span class="hljs-built_in">size</span>(); i++)<br>			&#123;<br>				Edge&amp; e = edges[G[x][i]];<br>				<span class="hljs-keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow)<br>				&#123;<span class="hljs-comment">//只考虑残量网络中的弧</span><br>					vis[e.to] = <span class="hljs-number">1</span>;<br>					d[e.to] = d[x] + <span class="hljs-number">1</span>;<span class="hljs-comment">//构造分层图</span><br>					q.<span class="hljs-built_in">push</span>(e.to);<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> vis[t];<span class="hljs-comment">//有无增广路,s-&gt;t</span><br>	&#125;<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> a)</span><span class="hljs-comment">//x为当前点,a为当前边上流量</span></span><br><span class="hljs-function">	</span>&#123;<span class="hljs-comment">//在层次图上向t延伸,多路增广</span><br>		<span class="hljs-keyword">if</span>(x==t||a==<span class="hljs-number">0</span>)<span class="hljs-comment">//到达目标/流量为0断流</span><br>			<span class="hljs-keyword">return</span> a;<br>		<span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>, f;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp; i=cur[x];i&lt;G[x].<span class="hljs-built_in">size</span>();i++)<span class="hljs-comment">//从上一次x遍历跑到的点开始跑</span><br>		&#123;<span class="hljs-comment">//从上次考虑的弧</span><br>			Edge&amp; e = edges[G[x][i]];<br>			<span class="hljs-keyword">if</span>(d[x]+<span class="hljs-number">1</span>==d[e.to]&amp;&amp;(f=<span class="hljs-built_in">DFS</span>(e.to,<span class="hljs-built_in">min</span>(a,e.cap-e.flow))) &gt; <span class="hljs-number">0</span>)<br>			&#123;<span class="hljs-comment">//只从层数编号较小的点到下一层的点</span><br>				e.flow += f;<span class="hljs-comment">//该路径上边流量都增加f</span><br>				edges[G[x][i]^<span class="hljs-number">1</span>].flow -= f;<span class="hljs-comment">//方便反悔</span><br>				flow += f;<br>				a -= f;<span class="hljs-comment">//用去可增广量</span><br>				<span class="hljs-keyword">if</span>(a==<span class="hljs-number">0</span>)<span class="hljs-comment">//a等于0及时退出</span><br>					<span class="hljs-keyword">break</span>;<span class="hljs-comment">//当a!=0,说明当前节点还存在另一个增广路分支。</span><br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(!flow)<span class="hljs-comment">//增广后容量满了</span><br>			d[x] = <span class="hljs-number">-1</span>;<span class="hljs-comment">//炸点优化,不必要的点下一次就不用遍历</span><br>		<span class="hljs-keyword">return</span> flow;<span class="hljs-comment">//返回x节点最大流量,传递到上一级</span><br>	&#125;<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Maxflow</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">this</span>-&gt;s = s, <span class="hljs-keyword">this</span>-&gt;t = t;<br>		<span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">while</span> (<span class="hljs-built_in">BFS</span>())<span class="hljs-comment">//不停地用bfs构造分层网络，然后用dfs沿着阻塞流增广</span><br>		&#123;<br>			<span class="hljs-built_in">memset</span>(cur, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(cur));<span class="hljs-comment">//建完分层图后cur也要初始化</span><br>			flow += <span class="hljs-built_in">DFS</span>(s,inf);<br>		&#125;<br>		<span class="hljs-keyword">return</span> flow;<br>	&#125;<br>&#125; di;<br></code></pre>

<h4 id="dijkstra费用流"><a href="#dijkstra费用流" class="headerlink" title="dijkstra费用流"></a>dijkstra费用流</h4><pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MCMF</span> &#123;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>		ll v, cap, cost, rev;<br>	&#125;;<br>	<span class="hljs-type">const</span> ll INF=<span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;<br>	ll flow, cost, s, t, n;<span class="hljs-comment">//前驱结点和对应边</span><br>	ll dist[maxn], H[maxn], pv[maxn], pe[maxn];<span class="hljs-comment">//H为节点势函数</span><br>	std::vector&lt;Edge&gt; G[maxn];<span class="hljs-comment">//因为要记录前驱,不能用前向星</span><br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>		<span class="hljs-keyword">this</span>-&gt;n = n;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) G[i].<span class="hljs-built_in">clear</span>();<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> cap, ll cost)</span></span>&#123;<span class="hljs-comment">//dojk费用流中两节点间流向单向</span><br>		G[u].<span class="hljs-built_in">push_back</span>(&#123;v,cap,cost,G[v].<span class="hljs-built_in">size</span>()&#125;);<br>		G[v].<span class="hljs-built_in">push_back</span>(&#123;u,<span class="hljs-number">0</span>,-cost,G[u].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>&#125;);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span><span class="hljs-comment">//这里是单路增广</span></span><br><span class="hljs-function">	</span>&#123;<span class="hljs-comment">//复杂度相对SPFA稳定</span><br>		std::priority_queue&lt;pair&lt;ll,ll&gt;, std::vector&lt;pair&lt;ll,ll&gt;&gt;, std::greater&lt;pair&lt;ll,ll&gt;&gt; &gt; q;<br>		std::<span class="hljs-built_in">fill</span>(dist, dist + n + <span class="hljs-number">1</span>, INF);<br>		dist[s] = <span class="hljs-number">0</span>; q.<span class="hljs-built_in">push</span>(&#123; <span class="hljs-number">0</span>, s &#125;);<br>		<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>		&#123;<span class="hljs-comment">//到x距离即为到x的单位花费之和</span><br>			pair&lt;ll,ll&gt; x = q.<span class="hljs-built_in">top</span>(); q.<span class="hljs-built_in">pop</span>();<br>			ll&amp; u = x.second;<br>			<span class="hljs-keyword">if</span> (dist[u] &lt; x.first) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//不能优化距离</span><br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G[u].<span class="hljs-built_in">size</span>(); ++i)<br>			&#123;<br>				Edge&amp; e = G[u][i];<span class="hljs-comment">//当前边</span><br>				ll&amp; v = e.v;<br>				<span class="hljs-function">pair&lt;ll,ll&gt; <span class="hljs-title">y</span><span class="hljs-params">(dist[u] + e.cost + H[u] - H[v], v)</span></span>;<br>				<span class="hljs-keyword">if</span> (e.cap &gt; <span class="hljs-number">0</span> &amp;&amp; dist[v] &gt; y.first)<br>				&#123;<br>					dist[v] = y.first;<br>					pv[v] = u,pe[v] = i;<span class="hljs-comment">//前驱点与前驱边</span><br>					q.<span class="hljs-built_in">push</span>(y);<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">if</span> (dist[t] == INF)<span class="hljs-comment">//无法增广</span><br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i)<span class="hljs-comment">//更新每轮的势函数</span><br>			H[i] += dist[i];<br>		ll f = INF;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = t; v != s; v = pv[v])<span class="hljs-comment">//沿增广路回到起点</span><br>			f = std::<span class="hljs-built_in">min</span>(f, G[pv[v]][pe[v]].cap);<br>		flow += f;<span class="hljs-comment">//每次增广一条路径,这条路径增广量就是新增的流量</span><br>		cost += f * H[t];<span class="hljs-comment">//h[t]-h[s]即为s到t的路径长</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = t; v != s; v = pv[v])<br>		&#123;<span class="hljs-comment">//更新增广路容量信息</span><br>			Edge&amp; e = G[pv[v]][pe[v]];<br>			e.cap -= f;<br>			G[v][e.rev].cap += f;<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	&#125;<br>	<span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">this</span>-&gt;s = s, <span class="hljs-keyword">this</span>-&gt;t = t;<br>		flow = cost = <span class="hljs-number">0</span>;<br>		std::<span class="hljs-built_in">fill</span>(H, H + n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">//初始网络为0非负,势函数也为0</span><br>		<span class="hljs-keyword">while</span> (<span class="hljs-built_in">dijkstra</span>());<span class="hljs-comment">//每次选择最小费用增广路径一定是当前残留图的最小增广路径</span><br>		<span class="hljs-keyword">return</span> flow;<br>	&#125;<br>&#125; mcmf;<br></code></pre>



<h4 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h4><h5 id="太空飞行计划问题（最小割-收益最大问题）"><a href="#太空飞行计划问题（最小割-收益最大问题）" class="headerlink" title="太空飞行计划问题（最小割,收益最大问题）"></a>太空飞行计划问题（最小割,收益最大问题）</h5><p> <strong>最优收益 &#x3D; 所有实验的报酬总和 - 该图的最大流</strong></p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-type">int</span> m,n;<span class="hljs-comment">//实验数,仪器数</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);<br><span class="hljs-type">int</span> s=<span class="hljs-number">0</span>,t=m+n+<span class="hljs-number">1</span>,sum=<span class="hljs-number">0</span>;<br>di.<span class="hljs-built_in">init</span>(t);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>&#123;<br>	<span class="hljs-type">int</span> profit,equ;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;profit);<br>	sum+=profit;<span class="hljs-comment">//sum为所有收益之和</span><br>	di.<span class="hljs-built_in">AddEdge</span>(s,i,profit);<span class="hljs-comment">//源点到实验</span><br>	<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>	&#123;<br>		<span class="hljs-type">char</span> ch;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%c&quot;</span>,&amp;equ,&amp;ch);<br>		di.<span class="hljs-built_in">AddEdge</span>(i,m+equ,inf);<span class="hljs-comment">//实验到器材</span><br>		<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;\r&#x27;</span>||ch==<span class="hljs-string">&#x27;\n&#x27;</span>)<br>			<span class="hljs-keyword">break</span>;<br>	&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br>	<span class="hljs-type">int</span> cost;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;cost);<br>	di.<span class="hljs-built_in">AddEdge</span>(m+i,t,cost);<span class="hljs-comment">//器材到汇点</span><br>&#125;<br><span class="hljs-type">int</span> ans=di.<span class="hljs-built_in">Maxflow</span>(s,t);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>&#123;<br>	<span class="hljs-keyword">if</span>(di.d[i])<span class="hljs-comment">//选择去做的实验编号</span><br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,i);<br>&#125;<br><span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br>	<span class="hljs-keyword">if</span>(di.d[m+i])<span class="hljs-comment">//需要购买的器材编号</span><br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,i);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d\n&quot;</span>,sum-ans);<br></code></pre>
<p>建图后跑最大流求出最小割，满流的实验边割掉，满流的设备边也在割集里(但是这是需要购买的)，该最小割即为最小亏损。<br>所以最后一次BFS，所有未被割掉的实验为非饱和弧，可以求出深度。<br>所以未被割掉的实验(及选择去做的实验)所连接的设备同样可以求出深度。</p>
<h5 id="最小路径覆盖问题-最大流-最小不相交路径覆盖模型-要求路径数最少-路径输出"><a href="#最小路径覆盖问题-最大流-最小不相交路径覆盖模型-要求路径数最少-路径输出" class="headerlink" title="最小路径覆盖问题(最大流,最小不相交路径覆盖模型,要求路径数最少,路径输出)"></a>最小路径覆盖问题(最大流,最小不相交路径覆盖模型,要求路径数最少,路径输出)</h5><p>二分图定理之一：最小路径覆盖数&#x3D;顶点数-最大匹配</p>
<p>不要使用炸点优化！！！</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-comment">//#pragma G++ optimize(&quot;O2&quot;)</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">13005</span>;<span class="hljs-comment">//上大的模板</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> nex[maxn];<br><span class="hljs-type">bool</span> vist[maxn];<br><span class="hljs-type">int</span> all;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dinic</span><br>&#123;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span><br>	&#123;<br>		<span class="hljs-type">int</span> from, to, cap, flow;<br>		<span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> f):<br>			<span class="hljs-built_in">from</span>(u), <span class="hljs-built_in">to</span>(v), <span class="hljs-built_in">cap</span>(c), <span class="hljs-built_in">flow</span>(f) &#123;&#125;<br>	&#125;;<br>	<span class="hljs-type">int</span> n, m, s, t; <span class="hljs-comment">//结点数,边数(包括反向弧),源点编号和汇点编号</span><br>	vector&lt;Edge&gt; edges; <span class="hljs-comment">//边表。edge[e]和edge[e^1]互为反向弧</span><br>	vector&lt;<span class="hljs-type">int</span>&gt; G[maxn]; <span class="hljs-comment">//邻接表，G[i][j]表示节点i的第j条边在e数组中的序号</span><br>	<span class="hljs-type">bool</span> vis[maxn]; <span class="hljs-comment">//BFS使用</span><br>	<span class="hljs-type">int</span> d[maxn]; <span class="hljs-comment">//从起点到i的距离</span><br>	<span class="hljs-type">int</span> cur[maxn]; <span class="hljs-comment">//当前弧下标</span><br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">this</span>-&gt;n = n;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)<br>			G[i].<span class="hljs-built_in">clear</span>();<br>		edges.<span class="hljs-built_in">clear</span>();<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">AddEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, <span class="hljs-type">int</span> cap)</span></span><br><span class="hljs-function">    </span>&#123;<br>        edges.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">Edge</span>(from, to, cap, <span class="hljs-number">0</span>));<span class="hljs-comment">//魔改蔡队模板</span><br>        edges.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">Edge</span>(to, from, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)); <span class="hljs-comment">//反向弧</span><br>        <span class="hljs-keyword">this</span>-&gt;m = edges.<span class="hljs-built_in">size</span>();<br>        G[from].<span class="hljs-built_in">push_back</span>(m - <span class="hljs-number">2</span>);<br>        G[to].<span class="hljs-built_in">push_back</span>(m - <span class="hljs-number">1</span>);<br>    &#125;<br>	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">BFS</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>		<span class="hljs-built_in">memset</span>(d, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(d));<br>		queue&lt;<span class="hljs-type">int</span>&gt; q;<br>		q.<span class="hljs-built_in">push</span>(s);<br>		d[s] = <span class="hljs-number">0</span>;<br>		vis[s] = <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>		&#123;<br>			<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>			q.<span class="hljs-built_in">pop</span>();<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G[x].<span class="hljs-built_in">size</span>(); i++)<br>			&#123;<br>				Edge&amp; e = edges[G[x][i]];<br>				<span class="hljs-keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow)<br>				&#123;<br>					vis[e.to] = <span class="hljs-number">1</span>;<br>					d[e.to] = d[x] + <span class="hljs-number">1</span>;<br>					q.<span class="hljs-built_in">push</span>(e.to);<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> vis[t];<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> a)</span><span class="hljs-comment">//x为当前点,a为当前边上流量</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">if</span> (x == t || a == <span class="hljs-number">0</span>)<span class="hljs-comment">//到达目标/流量为0</span><br>			<span class="hljs-keyword">return</span> a;<br>		<span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>, f;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>&amp; i = cur[x]; i &lt; G[x].<span class="hljs-built_in">size</span>(); i++)<br>		&#123; <span class="hljs-comment">//从上次考虑的弧</span><br>			Edge&amp; e = edges[G[x][i]];<br>			<span class="hljs-keyword">if</span> (d[x] + <span class="hljs-number">1</span> == d[e.to] &amp;&amp; (f = <span class="hljs-built_in">DFS</span>(e.to, <span class="hljs-built_in">min</span>(a, e.cap - e.flow))) &gt; <span class="hljs-number">0</span>)<br>			&#123;<br>				<span class="hljs-keyword">if</span>(x!=s)<span class="hljs-comment">//为了输出路径，添加此语句</span><br>				&#123;<br>					nex[x]=e.to;<span class="hljs-comment">//记录下一个节点,便于输出</span><br>					vist[e.to-all]=<span class="hljs-number">1</span>;<span class="hljs-comment">//打标记,找起点</span><br>				&#125;<br>				e.flow += f;<br>				edges[G[x][i] ^ <span class="hljs-number">1</span>].flow -= f;<br>				flow += f;<br>				a -= f;<br>				<span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span>)<br>					<span class="hljs-keyword">break</span>;<br>			&#125;<br>		&#125;<span class="hljs-comment">//这题不能乱用炸点优化！！！</span><br>		<span class="hljs-keyword">return</span> flow;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Maxflow</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">this</span>-&gt;s = s, <span class="hljs-keyword">this</span>-&gt;t = t;<br>		<span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">while</span> (<span class="hljs-built_in">BFS</span>())<br>		&#123;<br>			<span class="hljs-built_in">memset</span>(cur, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(cur));<br>			flow += <span class="hljs-built_in">DFS</span>(s,inf);<br>		&#125;<br>		<span class="hljs-keyword">return</span> flow;<br>	&#125;<br>&#125; di;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//给定DAG图G</span><br>	<span class="hljs-type">int</span> n,m;<span class="hljs-comment">//n为DAG顶点数，m为边数</span><br>	<span class="hljs-built_in">memset</span>(vist,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vist));<br>	cin&gt;&gt;n&gt;&gt;m;<br>	all=n;<br>	<span class="hljs-type">int</span> s=<span class="hljs-number">0</span>,t=<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>;<br>	di.<span class="hljs-built_in">init</span>(t);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//拆点，分别连接s和t</span><br>	&#123;<br>		di.<span class="hljs-built_in">AddEdge</span>(s,i,<span class="hljs-number">1</span>);<br>		di.<span class="hljs-built_in">AddEdge</span>(n+i,t,<span class="hljs-number">1</span>);<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>	&#123;<br>		<span class="hljs-type">int</span> u,v;<br>		cin&gt;&gt;u&gt;&gt;v;<br>		di.<span class="hljs-built_in">AddEdge</span>(u,n+v,<span class="hljs-number">1</span>);<span class="hljs-comment">//容量为1</span><br>	&#125;<br>	<span class="hljs-type">int</span> ans=di.<span class="hljs-built_in">Maxflow</span>(s,t);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>	&#123;<br>		<span class="hljs-keyword">if</span>(!vist[i])<span class="hljs-comment">//没标记的就是起点</span><br>		&#123;<br>			<span class="hljs-type">int</span> now=i;<br>			cout&lt;&lt;now&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>			<span class="hljs-keyword">while</span>(nex[now]&amp;&amp;nex[now]!=t)<br>			&#123;<br>				cout&lt;&lt;nex[now]-n&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>				now=nex[now]-n;<br>			&#125;<br>			cout&lt;&lt;endl;<br>		&#125;<br>	&#125;<br>	cout&lt;&lt;n-ans&lt;&lt;endl;<span class="hljs-comment">//最少路径数</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre>

<h5 id="P2774-方格取数问题-最大流，最小割"><a href="#P2774-方格取数问题-最大流，最小割" class="headerlink" title="P2774 方格取数问题(最大流，最小割)"></a>P2774 方格取数问题(最大流，最小割)</h5><p> m*n 个方格棋盘中，每个方格中有一个正整数。从方格中取数，使任意 2 个数所在方格没有公共边，且取出的数的总和最大。</p>
<p>思路：黑白染色，按奇偶性建立二分图，奇连s，偶连t。枚举每个奇数性质的方格，连接相邻的偶数性质的方格。跑dinic求出最小割，总值减去最小割即为答案。</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> m,n;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);<span class="hljs-comment">//棋盘的行数和列数</span><br>    <span class="hljs-type">int</span> s=<span class="hljs-number">0</span>,t=m*n+<span class="hljs-number">1</span>,sum=<span class="hljs-number">0</span>;<span class="hljs-comment">//sum为总价值</span><br>    di.<span class="hljs-built_in">init</span>(t+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>	&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>		&#123;<br>			<span class="hljs-type">int</span> val,no;<br>			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;val);<span class="hljs-comment">//i行j列的数值</span><br>			sum+=val;<br>			no=n*(i<span class="hljs-number">-1</span>)+j;<span class="hljs-comment">//重点：一行n个</span><br>			<span class="hljs-keyword">if</span>((i+j)%<span class="hljs-number">2</span>)&#123;<span class="hljs-comment">//相邻的i+j奇偶性必定相斥</span><br>				di.<span class="hljs-built_in">AddEdge</span>(s,no,val);<span class="hljs-comment">//根据奇偶性连接</span><br>			&#125;<br>			<span class="hljs-keyword">else</span>&#123;<br>				di.<span class="hljs-built_in">AddEdge</span>(no,t,val);<br>			&#125;<br>		&#125;<br>	&#125;<span class="hljs-comment">//s与t的边插入结束</span><br>	<span class="hljs-type">int</span> nx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<span class="hljs-comment">//只枚举两个方向是不够的,因为是有向图</span><br>	<span class="hljs-type">int</span> ny[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<span class="hljs-comment">//m行</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<span class="hljs-comment">//n列</span><br>		&#123;<br>			<span class="hljs-type">int</span> no=n*(i<span class="hljs-number">-1</span>)+j;<br>			<span class="hljs-keyword">if</span>((i+j)%<span class="hljs-number">2</span>)&#123;<span class="hljs-comment">//二分图左边的节点,开始连接右面的节点</span><br>				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++)<span class="hljs-comment">//枚举方向,相邻的四个方格</span><br>				&#123;<br>					<span class="hljs-type">int</span> x=i+nx[k],y=j+ny[k];<span class="hljs-comment">//x与m轴同方向</span><br>					<span class="hljs-keyword">if</span>(x&lt;=<span class="hljs-number">0</span>||x&gt;m||y&lt;=<span class="hljs-number">0</span>||y&gt;n)<br>						<span class="hljs-keyword">continue</span>;<br>					<span class="hljs-type">int</span> no2=n*(x<span class="hljs-number">-1</span>)+y;<span class="hljs-comment">//相邻的方格编号</span><br>					di.<span class="hljs-built_in">AddEdge</span>(no,no2,inf);<br>				&#125;<br>			&#125;<br>		&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,sum-di.<span class="hljs-built_in">Maxflow</span>(s,t));<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre>

<h4 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h4><h5 id="P4012-深海机器人问题（物品在网格上）"><a href="#P4012-深海机器人问题（物品在网格上）" class="headerlink" title="P4012 深海机器人问题（物品在网格上）"></a>P4012 深海机器人问题（物品在网格上）</h5><p>物品在网格的边上，每条网格的边有权值，交叉点作为节点，在图上添加点和点之间的边，设容量为1，花费为-cost。</p>
<p>注意设置容量inf，费用为0的经过边，跑最小费用最大流，答案取负。</p>
<h5 id="P3356-火星探险问题（物品在交叉点上）"><a href="#P3356-火星探险问题（物品在交叉点上）" class="headerlink" title="P3356 火星探险问题（物品在交叉点上）"></a>P3356 火星探险问题（物品在交叉点上）</h5><p>物品在节点上，而且有障碍。</p>
<p>思路：拆点，若不为障碍，拆点间添加容量为inf，价值为0的边；若该点有所需物品，两点间额外添加一条容量为1价值为-val的边；</p>
<p>跑最小费用最大流即可，使用DFS输出路径。</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>	&#123;<br>		flag=<span class="hljs-number">0</span>;<br>		mm.<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,i);<span class="hljs-comment">//起点(1,1),出点1,第i号机器人</span><br>	&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MCMF::dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> no)</span><span class="hljs-comment">//第no号机器人到达了u节点</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> kx,ky,dir;<span class="hljs-comment">//0向下,1向右</span><br>	<span class="hljs-type">int</span> res=p*q+u;<span class="hljs-comment">//u节点的拆点编号</span><br>	<span class="hljs-keyword">if</span>(flag)<span class="hljs-comment">//no号到达了终点</span><br>		<span class="hljs-keyword">return</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;G[res].<span class="hljs-built_in">size</span>();i++)<br>	&#123;<br>		<span class="hljs-keyword">if</span>(flag)<br>			<span class="hljs-keyword">return</span>;<br>		<span class="hljs-keyword">if</span>(edges[G[res][i]].flow&gt;<span class="hljs-number">0</span>&amp;&amp;(edges[G[res][i]].to==u+<span class="hljs-number">1</span>||edges[G[res][i]].to==u+p))<span class="hljs-comment">//残余流量大于0</span><br>		&#123;<span class="hljs-comment">//q行,p列,x与q同方向,表示第几行</span><br>			edges[G[res][i]].flow--;<br>			<span class="hljs-keyword">if</span>(edges[G[res][i]].to==u+<span class="hljs-number">1</span>)<span class="hljs-comment">//向右</span><br>				dir=<span class="hljs-number">1</span>;<br>			<span class="hljs-keyword">else</span><br>				dir=<span class="hljs-number">0</span>;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,no,dir);<br>			<span class="hljs-keyword">if</span>(dir==<span class="hljs-number">1</span>)<br>                <span class="hljs-built_in">dfs</span>(x,y+<span class="hljs-number">1</span>,u+<span class="hljs-number">1</span>,no);<br><span class="hljs-comment">//				printf(&quot;(%d,%d)-&gt;(%d,%d)\n&quot;,x,y,x,y+1);</span><br>			<span class="hljs-keyword">else</span><br>                <span class="hljs-built_in">dfs</span>(x+<span class="hljs-number">1</span>,y,u+p,no);<br><span class="hljs-comment">//				printf(&quot;(%d,%d)-&gt;(%d,%d)\n&quot;,x,y,x+1,y);</span><br>			<span class="hljs-keyword">if</span>(edges[G[res][i]].to==p*q)<br>				flag=<span class="hljs-number">1</span>;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre>

<h5 id="P2604-扩容费用问题"><a href="#P2604-扩容费用问题" class="headerlink" title="P2604 扩容费用问题 "></a><a target="_blank" rel="noopener" href="https://www.luogu.org/problem/P2604">P2604 扩容费用问题 </a></h5><p>问题：给出DAG每条边的容量和扩容费用，1.求出1到n的最大流。2.求出1到n的最大流增加K所需的最小扩容费用。</p>
<p>先跑一个零费用最大流。利用残余网络进行费用流扩容，将原来的0费用网络添加新的费用边，并进行<strong>限流</strong>，cost即为扩容费用。</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-type">int</span> n,m,k;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>mm.<span class="hljs-built_in">init</span>(n+<span class="hljs-number">10</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>	cin&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].c&gt;&gt;e[i].w;<br>	mm.<span class="hljs-built_in">AddEdge</span>(e[i].u,e[i].v,e[i].c,<span class="hljs-number">0</span>);<span class="hljs-comment">//费用为0，跑最大流</span><br>&#125;<br>ll cost;<br>cout&lt;&lt;mm.<span class="hljs-built_in">MincostMaxflow</span>(<span class="hljs-number">1</span>,n,cost)&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<span class="hljs-comment">//给原来每条边上添加新边,</span><br>	mm.<span class="hljs-built_in">AddEdge</span>(e[i].u,e[i].v,inf,e[i].w);<br><span class="hljs-type">int</span> s=<span class="hljs-number">0</span>;<span class="hljs-comment">//超级源点s</span><br>mm.<span class="hljs-built_in">AddEdge</span>(s,<span class="hljs-number">1</span>,k,<span class="hljs-number">0</span>);<span class="hljs-comment">//s到1进行限流</span><br>mm.<span class="hljs-built_in">MincostMaxflow</span>(s,n,cost);<span class="hljs-comment">//费用流</span><br>cout&lt;&lt;cost&lt;&lt;endl;<span class="hljs-comment">//扩容费用</span><br></code></pre>






  </div>
  <div>
    
  </div>
</article>
<div class="nav">
  
    <div class="nav-item-prev">
      <a 
        href="/2022/09/30/gitIgnoreFiles/" 
        class="nav-link">
        <i class="iconfont icon-left nav-prev-icon"></i>
        <div>
          <div class="nav-label">上一篇</div>
          
            <div class="nav-title">git之忽略文件 </div>
          
        </div>
      </a>
    </div>
  
  
    <div class="nav-item-next">
      <a 
        href="/2022/09/30/howDoCSSClearul,liDefaultStyles/" 
        class="nav-link">
        <div>
          <div class="nav-label">下一篇</div>
          
            <div class="nav-title">css怎么清除ul,li默认样式？ </div>
          
        </div>
        <i class="iconfont icon-right nav-next-icon"></i>
      </a>
    </div>
  
</div>

<div 
  class="card card-content toc-card" 
  id="mobiletoc">
  <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>目录
</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E8%AE%BA"><span class="toc-text">图论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5"><span class="toc-text">常见概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%B5%81%E5%B8%B8%E7%94%A8%E6%A6%82%E5%BF%B5"><span class="toc-text">网络流常用概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%A6%E5%9B%BE%E5%B8%B8%E7%94%A8%E6%A6%82%E5%BF%B5"><span class="toc-text">弦图常用概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%BB%93%E8%AE%BA"><span class="toc-text">常见结论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%A6%E5%9B%BE"><span class="toc-text">弦图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%8A%BF%E7%AE%97%E6%B3%95%E6%B1%82%E6%B6%88%E9%99%A4%E5%BA%8F%E5%88%97%E5%B9%B6%E5%88%A4%E5%AE%9A%E5%BC%A6%E5%9B%BE"><span class="toc-text">最大势算法求消除序列并判定弦图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%85%83%E7%8E%AF"><span class="toc-text">三元环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-text">步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-text">最短路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dijkstra%E5%A0%86%E4%BC%98%E5%8C%96"><span class="toc-text">Dijkstra堆优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SPFA"><span class="toc-text">SPFA</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#BFS%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%89"><span class="toc-text">BFS实现（求最短路）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DFS%E4%BC%98%E5%8C%96%EF%BC%88%E8%B4%9F%E7%8E%AF%E6%A3%80%E6%B5%8B%EF%BC%89"><span class="toc-text">DFS优化（负环检测）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Floyd"><span class="toc-text">Floyd</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%9B%A2"><span class="toc-text">最大团</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%9B%A2%E5%A4%A7%E5%B0%8F"><span class="toc-text">最大团大小</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F"><span class="toc-text">差分约束</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95"><span class="toc-text">解法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-MST"><span class="toc-text">最小生成树(MST)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Prim%E7%AE%97%E6%B3%95"><span class="toc-text">Prim算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kruskal"><span class="toc-text">Kruskal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Boruvka"><span class="toc-text">Boruvka</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-text">流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E4%BE%8B%E9%A2%98"><span class="toc-text">典型例题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">次小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E6%B4%9B%E8%B0%B7P4180"><span class="toc-text">严格次小生成树(洛谷P4180)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88MDST%EF%BC%8C%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE%EF%BC%89"><span class="toc-text">有向图最小生成树（MDST，最小树形图）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%B1%E5%88%98%E7%AE%97%E6%B3%95%EF%BC%88Edmonds-%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-text">朱刘算法（Edmonds 算法）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B-1"><span class="toc-text">流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-text">模板</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%A0%91"><span class="toc-text">虚树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1"><span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%9B%BE%E6%90%9C%E7%B4%A2"><span class="toc-text">补图搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%9B%BE%E8%BF%9E%E9%80%9A%E5%9D%97-0-1-MST"><span class="toc-text">补图连通块 0-1 MST </span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="toc-text">强连通分量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Tarjan"><span class="toc-text">Tarjan</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Tarjan%E7%BC%A9%E7%82%B9-DAG-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8Fdp"><span class="toc-text">Tarjan缩点+DAG 拓扑排序dp</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Tarjan%E6%97%A0%E5%90%91%E5%9B%BE%E6%B1%82%E5%89%B2%E7%82%B9"><span class="toc-text">Tarjan无向图求割点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E6%B1%82%E6%A1%A5"><span class="toc-text">无向图求桥</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-SAT%E9%97%AE%E9%A2%98"><span class="toc-text">2-SAT问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B-2"><span class="toc-text">流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BB%BA%E5%9B%BE%E6%96%B9%E5%BC%8F"><span class="toc-text">建图方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-LCA"><span class="toc-text">最近公共祖先(LCA)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%8D%E5%A2%9E"><span class="toc-text">倍增</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-text">应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86"><span class="toc-text">树上差分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8"><span class="toc-text">性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%82%B9%E7%9A%84%E5%B7%AE%E5%88%86"><span class="toc-text">点的差分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C"><span class="toc-text">操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9"><span class="toc-text">修改</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E7%9A%84%E5%B7%AE%E5%88%86"><span class="toc-text">边的差分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C-1"><span class="toc-text">操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9-1"><span class="toc-text">修改</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2"><span class="toc-text">查询</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86"><span class="toc-text">树链剖分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF"><span class="toc-text">通用模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P3384-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86"><span class="toc-text">P3384 树链剖分 </span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E5%88%86%E6%B2%BB"><span class="toc-text">点分治</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83"><span class="toc-text">树的重心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B-3"><span class="toc-text">流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6%EF%BC%88DSU-on-tree%EF%BC%89"><span class="toc-text">树上启发式合并（DSU on tree）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B-4"><span class="toc-text">流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="toc-text">二分图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E4%BA%8C%E5%88%86%E5%9B%BE%E7%BB%93%E8%AE%BA"><span class="toc-text">常见二分图结论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E4%BB%BB%E6%84%8F%E5%9B%BE%E7%9A%84%E7%BB%93%E8%AE%BA"><span class="toc-text">适用任意图的结论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E5%88%A4%E5%AE%9A%EF%BC%88%E9%BB%91%E7%99%BD%E6%9F%93%E8%89%B2%E6%B3%95%EF%BC%89"><span class="toc-text">二分图判定（黑白染色法）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95"><span class="toc-text">匈牙利算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-text">邻接表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KM%E7%AE%97%E6%B3%95"><span class="toc-text">KM算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#BFS%EF%BC%8C%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A8%B3%E7%9A%84%E4%B8%80%E6%89%B9"><span class="toc-text">BFS，复杂度稳的一批</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A6%E5%8F%B3%E6%95%B0%E7%9B%AE%E4%B8%8D%E7%AD%89%E7%9A%84%E6%A8%A1%E6%9D%BF"><span class="toc-text">左右数目不等的模板</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CSL%E7%9A%84%E5%86%99%E6%B3%95"><span class="toc-text">CSL的写法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%B5%81"><span class="toc-text">网络流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E9%83%A8%E5%88%86"><span class="toc-text">模板部分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#dinic"><span class="toc-text">dinic</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dijkstra%E8%B4%B9%E7%94%A8%E6%B5%81"><span class="toc-text">dijkstra费用流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%B5%81"><span class="toc-text">最大流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%AA%E7%A9%BA%E9%A3%9E%E8%A1%8C%E8%AE%A1%E5%88%92%E9%97%AE%E9%A2%98%EF%BC%88%E6%9C%80%E5%B0%8F%E5%89%B2-%E6%94%B6%E7%9B%8A%E6%9C%80%E5%A4%A7%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-text">太空飞行计划问题（最小割,收益最大问题）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98-%E6%9C%80%E5%A4%A7%E6%B5%81-%E6%9C%80%E5%B0%8F%E4%B8%8D%E7%9B%B8%E4%BA%A4%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E6%A8%A1%E5%9E%8B-%E8%A6%81%E6%B1%82%E8%B7%AF%E5%BE%84%E6%95%B0%E6%9C%80%E5%B0%91-%E8%B7%AF%E5%BE%84%E8%BE%93%E5%87%BA"><span class="toc-text">最小路径覆盖问题(最大流,最小不相交路径覆盖模型,要求路径数最少,路径输出)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#P2774-%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0%E9%97%AE%E9%A2%98-%E6%9C%80%E5%A4%A7%E6%B5%81%EF%BC%8C%E6%9C%80%E5%B0%8F%E5%89%B2"><span class="toc-text">P2774 方格取数问题(最大流，最小割)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%B9%E7%94%A8%E6%B5%81"><span class="toc-text">费用流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#P4012-%E6%B7%B1%E6%B5%B7%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%97%AE%E9%A2%98%EF%BC%88%E7%89%A9%E5%93%81%E5%9C%A8%E7%BD%91%E6%A0%BC%E4%B8%8A%EF%BC%89"><span class="toc-text">P4012 深海机器人问题（物品在网格上）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#P3356-%E7%81%AB%E6%98%9F%E6%8E%A2%E9%99%A9%E9%97%AE%E9%A2%98%EF%BC%88%E7%89%A9%E5%93%81%E5%9C%A8%E4%BA%A4%E5%8F%89%E7%82%B9%E4%B8%8A%EF%BC%89"><span class="toc-text">P3356 火星探险问题（物品在交叉点上）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#P2604-%E6%89%A9%E5%AE%B9%E8%B4%B9%E7%94%A8%E9%97%AE%E9%A2%98"><span class="toc-text">P2604 扩容费用问题 </span></a></li></ol></li></ol></li></ol></li></ol>
</div>

            </main>
            <aside class="right-column">
              <div class="sticky-widescreen">
  
  
    <article class="card card-content toc-card">
      <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>目录
</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E8%AE%BA"><span class="toc-text">图论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5"><span class="toc-text">常见概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%B5%81%E5%B8%B8%E7%94%A8%E6%A6%82%E5%BF%B5"><span class="toc-text">网络流常用概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%A6%E5%9B%BE%E5%B8%B8%E7%94%A8%E6%A6%82%E5%BF%B5"><span class="toc-text">弦图常用概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%BB%93%E8%AE%BA"><span class="toc-text">常见结论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%A6%E5%9B%BE"><span class="toc-text">弦图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%8A%BF%E7%AE%97%E6%B3%95%E6%B1%82%E6%B6%88%E9%99%A4%E5%BA%8F%E5%88%97%E5%B9%B6%E5%88%A4%E5%AE%9A%E5%BC%A6%E5%9B%BE"><span class="toc-text">最大势算法求消除序列并判定弦图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%85%83%E7%8E%AF"><span class="toc-text">三元环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-text">步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-text">最短路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dijkstra%E5%A0%86%E4%BC%98%E5%8C%96"><span class="toc-text">Dijkstra堆优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SPFA"><span class="toc-text">SPFA</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#BFS%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%89"><span class="toc-text">BFS实现（求最短路）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DFS%E4%BC%98%E5%8C%96%EF%BC%88%E8%B4%9F%E7%8E%AF%E6%A3%80%E6%B5%8B%EF%BC%89"><span class="toc-text">DFS优化（负环检测）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Floyd"><span class="toc-text">Floyd</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%9B%A2"><span class="toc-text">最大团</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%9B%A2%E5%A4%A7%E5%B0%8F"><span class="toc-text">最大团大小</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F"><span class="toc-text">差分约束</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95"><span class="toc-text">解法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-MST"><span class="toc-text">最小生成树(MST)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Prim%E7%AE%97%E6%B3%95"><span class="toc-text">Prim算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kruskal"><span class="toc-text">Kruskal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Boruvka"><span class="toc-text">Boruvka</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-text">流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E4%BE%8B%E9%A2%98"><span class="toc-text">典型例题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">次小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E6%B4%9B%E8%B0%B7P4180"><span class="toc-text">严格次小生成树(洛谷P4180)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88MDST%EF%BC%8C%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE%EF%BC%89"><span class="toc-text">有向图最小生成树（MDST，最小树形图）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%B1%E5%88%98%E7%AE%97%E6%B3%95%EF%BC%88Edmonds-%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-text">朱刘算法（Edmonds 算法）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B-1"><span class="toc-text">流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-text">模板</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%A0%91"><span class="toc-text">虚树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1"><span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%9B%BE%E6%90%9C%E7%B4%A2"><span class="toc-text">补图搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%9B%BE%E8%BF%9E%E9%80%9A%E5%9D%97-0-1-MST"><span class="toc-text">补图连通块 0-1 MST </span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="toc-text">强连通分量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Tarjan"><span class="toc-text">Tarjan</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Tarjan%E7%BC%A9%E7%82%B9-DAG-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8Fdp"><span class="toc-text">Tarjan缩点+DAG 拓扑排序dp</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Tarjan%E6%97%A0%E5%90%91%E5%9B%BE%E6%B1%82%E5%89%B2%E7%82%B9"><span class="toc-text">Tarjan无向图求割点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E6%B1%82%E6%A1%A5"><span class="toc-text">无向图求桥</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-SAT%E9%97%AE%E9%A2%98"><span class="toc-text">2-SAT问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B-2"><span class="toc-text">流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BB%BA%E5%9B%BE%E6%96%B9%E5%BC%8F"><span class="toc-text">建图方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-LCA"><span class="toc-text">最近公共祖先(LCA)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%8D%E5%A2%9E"><span class="toc-text">倍增</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-text">应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86"><span class="toc-text">树上差分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8"><span class="toc-text">性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%82%B9%E7%9A%84%E5%B7%AE%E5%88%86"><span class="toc-text">点的差分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C"><span class="toc-text">操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9"><span class="toc-text">修改</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E7%9A%84%E5%B7%AE%E5%88%86"><span class="toc-text">边的差分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C-1"><span class="toc-text">操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9-1"><span class="toc-text">修改</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2"><span class="toc-text">查询</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86"><span class="toc-text">树链剖分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF"><span class="toc-text">通用模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P3384-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86"><span class="toc-text">P3384 树链剖分 </span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E5%88%86%E6%B2%BB"><span class="toc-text">点分治</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83"><span class="toc-text">树的重心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B-3"><span class="toc-text">流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6%EF%BC%88DSU-on-tree%EF%BC%89"><span class="toc-text">树上启发式合并（DSU on tree）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B-4"><span class="toc-text">流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="toc-text">二分图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E4%BA%8C%E5%88%86%E5%9B%BE%E7%BB%93%E8%AE%BA"><span class="toc-text">常见二分图结论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E4%BB%BB%E6%84%8F%E5%9B%BE%E7%9A%84%E7%BB%93%E8%AE%BA"><span class="toc-text">适用任意图的结论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E5%88%A4%E5%AE%9A%EF%BC%88%E9%BB%91%E7%99%BD%E6%9F%93%E8%89%B2%E6%B3%95%EF%BC%89"><span class="toc-text">二分图判定（黑白染色法）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95"><span class="toc-text">匈牙利算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-text">邻接表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KM%E7%AE%97%E6%B3%95"><span class="toc-text">KM算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#BFS%EF%BC%8C%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A8%B3%E7%9A%84%E4%B8%80%E6%89%B9"><span class="toc-text">BFS，复杂度稳的一批</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A6%E5%8F%B3%E6%95%B0%E7%9B%AE%E4%B8%8D%E7%AD%89%E7%9A%84%E6%A8%A1%E6%9D%BF"><span class="toc-text">左右数目不等的模板</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CSL%E7%9A%84%E5%86%99%E6%B3%95"><span class="toc-text">CSL的写法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%B5%81"><span class="toc-text">网络流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E9%83%A8%E5%88%86"><span class="toc-text">模板部分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#dinic"><span class="toc-text">dinic</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dijkstra%E8%B4%B9%E7%94%A8%E6%B5%81"><span class="toc-text">dijkstra费用流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%B5%81"><span class="toc-text">最大流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%AA%E7%A9%BA%E9%A3%9E%E8%A1%8C%E8%AE%A1%E5%88%92%E9%97%AE%E9%A2%98%EF%BC%88%E6%9C%80%E5%B0%8F%E5%89%B2-%E6%94%B6%E7%9B%8A%E6%9C%80%E5%A4%A7%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-text">太空飞行计划问题（最小割,收益最大问题）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98-%E6%9C%80%E5%A4%A7%E6%B5%81-%E6%9C%80%E5%B0%8F%E4%B8%8D%E7%9B%B8%E4%BA%A4%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E6%A8%A1%E5%9E%8B-%E8%A6%81%E6%B1%82%E8%B7%AF%E5%BE%84%E6%95%B0%E6%9C%80%E5%B0%91-%E8%B7%AF%E5%BE%84%E8%BE%93%E5%87%BA"><span class="toc-text">最小路径覆盖问题(最大流,最小不相交路径覆盖模型,要求路径数最少,路径输出)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#P2774-%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0%E9%97%AE%E9%A2%98-%E6%9C%80%E5%A4%A7%E6%B5%81%EF%BC%8C%E6%9C%80%E5%B0%8F%E5%89%B2"><span class="toc-text">P2774 方格取数问题(最大流，最小割)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%B9%E7%94%A8%E6%B5%81"><span class="toc-text">费用流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#P4012-%E6%B7%B1%E6%B5%B7%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%97%AE%E9%A2%98%EF%BC%88%E7%89%A9%E5%93%81%E5%9C%A8%E7%BD%91%E6%A0%BC%E4%B8%8A%EF%BC%89"><span class="toc-text">P4012 深海机器人问题（物品在网格上）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#P3356-%E7%81%AB%E6%98%9F%E6%8E%A2%E9%99%A9%E9%97%AE%E9%A2%98%EF%BC%88%E7%89%A9%E5%93%81%E5%9C%A8%E4%BA%A4%E5%8F%89%E7%82%B9%E4%B8%8A%EF%BC%89"><span class="toc-text">P3356 火星探险问题（物品在交叉点上）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#P2604-%E6%89%A9%E5%AE%B9%E8%B4%B9%E7%94%A8%E9%97%AE%E9%A2%98"><span class="toc-text">P2604 扩容费用问题 </span></a></li></ol></li></ol></li></ol></li></ol>
    </article>
  
  
  <article class="card card-content">
    <div class="recent-posts-card">
  <div class="recent-posts-header">
    <i 
      class="iconfont icon-wenzhang_huaban" 
      style="padding-right: 2px;">
    </i>最近文章
  </div>
  <div class="recent-posts-list">
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-10-21</div>
        <a href="/2022/10/21/22102101/"><div class="recent-posts-item-content">《普通破盾学》(正式版)</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-10-21</div>
        <a href="/2022/10/21/22102102/"><div class="recent-posts-item-content">伤害乘区论</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-10-21</div>
        <a href="/2022/10/21/22102103/"><div class="recent-posts-item-content">抗打断和冲击效果的原理</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-10-21</div>
        <a href="/2022/10/21/22102104/"><div class="recent-posts-item-content">国家队配对需求以及输出</div></a>
      </div>
    
  </div>
</div>
  </article>
  
  
  <article class="card card-content">
    <h1 style="padding-bottom: 12px;">关注嘉然！顿顿解馋！</h1>
    <img src="https://api2.mubu.com/v3/document_image/2697c6ae-10ee-41a3-9099-304bdb252d31-3807603.jpg">
  </article>
</div>
            </aside>
          </div>
        </div>
      </div>
    </div>
     
    <footer class="footer">
  <div class="footer-container">
    <div>
      <div class="footer-dsc">
        <span>
          Copyright ©
          
            2020
          
          
                - 
                2022
          
        </span>
        &nbsp;
        <a 
          href="/" 
          class="footer-link">
          霜序廿的个人网站
        </a>
      </div>
    </div>

    
      <div class="footer-dsc">
        
          Powered by
          <a 
            href="https://hexo.io/" 
            class="footer-link" 
            target="_blank" 
            rel="nofollow noopener noreferrer">
            &nbsp;Hexo
          </a>
        
        
          <span>&nbsp;|&nbsp;</span>
        
        
          Theme -
          <a 
            href="https://github.com/theme-kaze" 
            class="footer-link" 
            target="_blank"
            rel="nofollow noopener noreferrer">
            &nbsp;Kaze
          </a>
        
      </div>
    
    
    
    
</footer>
 
    
  <a 
    role="button" 
    id="scrollbutton" 
    class="basebutton" 
    aria-label="回到顶部">
    <i class="iconfont icon-arrowleft button-icon"></i>
  </a>

<a 
  role="button" 
  id="menubutton"
  aria-label="menu button"
  class="basebutton">
  <i class="iconfont icon-menu button-icon"></i>
</a>
<a 
  role="button" 
  id="popbutton" 
  class="basebutton" 
  aria-label="控制中心">
  <i class="iconfont icon-expand button-icon"></i>
</a>
<a 
  role="button" 
  id="darkbutton" 
  class="basebutton darkwidget" 
  aria-label="夜色模式">
  <i class="iconfont icon-weather button-icon"></i>
</a>
<a 
  role="button" 
  id="searchbutton" 
  class="basebutton searchwidget" 
  aria-label="搜索">
  <i class="iconfont icon-search button-icon"></i>
</a> 
     
     
     
      <script>
  var addImgLayout = function () {
    var img = document.querySelectorAll('.post-content img')
    var i
    for (i = 0; i < img.length; i++) {
      var wrapper = document.createElement('a')
      wrapper.setAttribute('href', img[i].getAttribute('data-src'))
      wrapper.setAttribute('aria-label', 'illustration')
      wrapper.style.cssText =
        'width: 100%; display: flex; justify-content: center;'
      if (img[i].alt) wrapper.dataset.caption = img[i].alt
      wrapper.dataset.nolink = true
      img[i].before(wrapper)
      wrapper.append(img[i])
      var divWrap = document.createElement('div')
      divWrap.classList.add('gallery')
      wrapper.before(divWrap)
      divWrap.append(wrapper)
    }
    baguetteBox.run('.gallery')
  }
</script>
<script>
  loadScript(
    "/js/lib/lightbox/baguetteBox.min.js",
    addImgLayout
  )
</script>
 
     
     
    <script src="/js/main.js"></script> 
     
    
      <script>
        var addLazyload = function () {
          var observer = lozad('.lozad', {
            load: function (el) {
              el.srcset = el.getAttribute('data-src')
            },
            loaded: function (el) {
              el.classList.add('loaded')
            },
          })
          observer.observe()
        }
      </script>
      <script>
        loadScript('/js/lib/lozad.min.js', addLazyload)
      </script>
    
    <script src="//instant.page/5.1.0" type="module"
      integrity="sha384-by67kQnR+pyfy8yWP4kPO12fHKRLHZPfEsiSXR8u2IKcTdxD805MGUXBzVPnkLHw"></script>
    
    
  </body>
</html>
