<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta charset="UTF-8">
  <meta 
    name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta 
    http-equiv="X-UA-Compatible" 
    content="ie=edge">
  <meta 
    name="theme-color" 
    content="#fff" 
    id="theme-color">
  <meta 
    name="description" 
    content="记录个人成长与生活，前端，算法，nlp">
  <link 
    rel="icon" 
    href="https://q2.qlogo.cn/headimg_dl?dst_uin=2749909223&amp;spec=5">
  <title>axios如何利用promise无痛刷新token</title>
  
    
      <meta 
        property="og:title" 
        content="axios如何利用promise无痛刷新token">
    
    
      <meta 
        property="og:url" 
        content="http://example.com/2022/09/30/22092624/index.html">
    
    
      <meta 
        property="og:img" 
        content="https://q2.qlogo.cn/headimg_dl?dst_uin=2749909223&amp;spec=5">
    
    
      <meta 
        property="og:img" 
        content="如题目">
    
    
      <meta 
        property="og:type" 
        content="article">
      <meta 
        property="og:article:published_time" 
        content="2022-09-30">
      <meta 
        property="og:article:modified_time" 
        content="2022-09-30">
      <meta 
        property="og:article:author" 
        content="霜序廿">
      
        
          <meta 
            property="og:article:tag" 
            content="js">
        
          <meta 
            property="og:article:tag" 
            content="axios">
        
      
    
  
  
  <link rel="preload" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css" as="style" >
  <link rel="preload" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css" as="style" >
  <link rel="preload" href="/css/main.css" as="style" >
  
  <link rel="modulepreload" href="//instant.page/5.1.0">
  
  <link rel="stylesheet" href="/css/main.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css">
  
  
  
    <link rel="stylesheet" href="/js/lib/lightbox/baguetteBox.min.css">
  
  <script>
    function loadScript(url, cb) {
      var script = document.createElement('script');
      script.src = url;
      if (cb) script.onload = cb;
      script.async = true;
      document.body.appendChild(script);
    }
    function loadCSS(href, data, attr) {
      var sheet = document.createElement('link');
      sheet.ref = 'stylesheet';
      sheet.href = href;
      sheet.dataset[data] = attr;
      document.head.appendChild(sheet);
    }
    function changeCSS(cssFile, data, attr) {
      var oldlink = document.querySelector(data);
      var newlink = document.createElement("link");
      newlink.setAttribute("rel", "stylesheet");
      newlink.setAttribute("href", cssFile);
      newlink.dataset.prism = attr;
      document.head.replaceChild(newlink, oldlink);
    }
  </script>
  
    
  
  <script>
    // control reverse button
    var reverseDarkList = {
      dark: 'light',
      light: 'dark'
    };
    var themeColor = {
      dark: '#1c1c1e',
      light: '#fff'
    }
    // get the data of css prefers-color-scheme
    var getCssMediaQuery = function() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };
    // reverse current darkmode setting function
    var reverseDarkModeSetting = function() {
      var setting = localStorage.getItem('user-color-scheme');
      if(reverseDarkList[setting]) {
        setting = reverseDarkList[setting];
      } else if(setting === null) {
        setting = reverseDarkList[getCssMediaQuery()];
      } else {
        return;
      }
      localStorage.setItem('user-color-scheme', setting);
      return setting;
    };
    // apply current darkmode setting
  </script>
  
    <script>
      var setDarkmode = function(mode) {
      var setting = mode || localStorage.getItem('user-color-scheme');
      if(setting === getCssMediaQuery()) {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[setting];
        document.getElementById('theme-color').dataset.mode = setting;
      } else if(reverseDarkList[setting]) {
        document.documentElement.setAttribute('data-user-color-scheme', setting);
        document.getElementById('theme-color').content = themeColor[setting];
        document.getElementById('theme-color').dataset.mode = setting;
      } else {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[getCssMediaQuery()];
        document.getElementById('theme-color').dataset.mode = getCssMediaQuery();
      }
    };
    setDarkmode();
    </script>
  
  
  
    <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.js" as="script">
    <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.css" as="style" >
  
  
    <link rel="preload" href="/js/lib/lozad.min.js" as="script">
  
  
  
  
  
  
<meta name="generator" content="Hexo 6.3.0"></head>

  <body>
    <div class="wrapper">
       
      <nav class="navbar">
  <div class="navbar-logo">
    <a class="navbar-logo-main" href="/">
      
        <img 
          class="navbar-logo-img"
          width="32"
          height="32"
          src="https://q2.qlogo.cn/headimg_dl?dst_uin=2749909223&spec=5" 
          alt="blog logo">
      
      <span class="navbar-logo-dsc">霜序廿的个人网站</span>
      </a>
  </div>
  <div class="navbar-menu">
    
      <a 
        href="/" 
        class="navbar-menu-item">
        
          首页
        
      </a>
    
      <a 
        href="/archives" 
        class="navbar-menu-item">
        
          归档
        
      </a>
    
      <a 
        href="/tags" 
        class="navbar-menu-item">
        
          标签
        
      </a>
    
      <a 
        href="/categories" 
        class="navbar-menu-item">
        
          分类
        
      </a>
    
      <a 
        href="/about" 
        class="navbar-menu-item">
        
          关于
        
      </a>
    
      <a 
        href="/links" 
        class="navbar-menu-item">
        
          友链
        
      </a>
    
    <button 
      class="navbar-menu-item darknavbar navbar-menu-btn" 
      aria-label="Toggle dark mode"
      id="dark">
      <i class="iconfont icon-weather"></i>
    </button>
    <button 
      class="navbar-menu-item searchnavbar navbar-menu-btn" 
      aria-label="Toggle search"
      id="search">
      <!-- <i 
        class="iconfont icon-search" 
        style="font-size: 1.2rem; font-weight: 400;">
      </i> -->
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img"
        class="iconify iconify--ion" width="28" height="28" preserveAspectRatio="xMidYMid meet" viewBox="0 0 512 512">
        <path fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="28"
          d="M256 80a176 176 0 1 0 176 176A176 176 0 0 0 256 80Z"></path>
        <path fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="28"
          d="M232 160a72 72 0 1 0 72 72a72 72 0 0 0-72-72Z"></path>
        <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="28"
          d="M283.64 283.64L336 336"></path>
      </svg>
    </button>
  </div>
</nav> 
      
      <div 
        id="local-search" 
        style="display: none">
        <input
          class="navbar-menu-item"
          id="search-input"
          placeholder="请输入搜索内容..." />
        <div id="search-content"></div>
      </div>
      
      <div class="section-wrap">
        <div class="container">
          <div class="columns">
            <aside class="left-column">
              
              <div class="card card-author">
                
  <img 
    src="https://q2.qlogo.cn/headimg_dl?dst_uin=2749909223&spec=5" 
    class="author-img"
    width="88"
    height="88"
    alt="author avatar">

<p class="author-name">霜序廿</p>
<p class="author-description">一个爱算法的小前端</p>
<div class="author-message">
  <a 
    class="author-posts-count" 
    href="/archives">
    <span>252</span>
    <span>文章</span>
  </a>
  <a 
    class="author-categories-count" 
    href="/categories">
    <span>7</span>
    <span>分类</span>
  </a>
  <a 
    class="author-tags-count" 
    href="/tags">
    <span>52</span>
    <span>标签</span>
  </a>
</div>

  <div class="author-card-society">
    
      <div class="author-card-society-icon">
        <a target="_blank" rel="noopener" href="https://github.com/shuangxunian">
          <i class="iconfont icon-github society-icon"></i>
        </a>
      </div>
    
      <div class="author-card-society-icon">
        <a target="_blank" rel="noopener" href="https://space.bilibili.com/391117803">
          <i class="iconfont icon-bilibili society-icon"></i>
        </a>
      </div>
    
  </div>

              </div>
               <div class="sticky-tablet">
  
  
    <article class="display-when-two-columns spacer">
      <div class="card card-content toc-card">
        <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>目录
</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82"><span class="toc-text">需求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E8%A7%A3%E6%9E%90"><span class="toc-text">需求解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-text">实现思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80"><span class="toc-text">方法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C"><span class="toc-text">方法二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="toc-text">两种方法对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80-1"><span class="toc-text">方法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C-1"><span class="toc-text">方法二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85axios%E5%9F%BA%E6%9C%AC%E9%AA%A8%E6%9E%B6"><span class="toc-text">封装axios基本骨架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instance-interceptors-response-use%E6%8B%A6%E6%88%AA%E5%AE%9E%E7%8E%B0"><span class="toc-text">instance.interceptors.response.use拦截实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%92%8C%E4%BC%98%E5%8C%96"><span class="toc-text">问题和优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%A4%9A%E6%AC%A1%E5%88%B7%E6%96%B0token"><span class="toc-text">如何防止多次刷新token</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E5%8F%91%E8%B5%B7%E4%B8%A4%E4%B8%AA%E6%88%96%E4%BB%A5%E4%B8%8A%E7%9A%84%E8%AF%B7%E6%B1%82%E6%97%B6%EF%BC%8C%E5%85%B6%E4%BB%96%E6%8E%A5%E5%8F%A3%E5%A6%82%E4%BD%95%E9%87%8D%E8%AF%95"><span class="toc-text">同时发起两个或以上的请求时，其他接口如何重试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-text">完整代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-text">参考链接</span></a></li></ol>
      </div>
    </article>
  
  
  <article class="card card-content categories-widget">
    <div class="categories-card">
  <div class="categories-header">
    <i 
      class="iconfont icon-fenlei" 
      style="padding-right: 2px;">
    </i>分类
  </div>
  <div class="categories-list">
    
      <a href="/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/">
        <div class="categories-list-item">
          技术文章
          <span class="categories-list-item-badge">217</span>
        </div>
      </a>
    
      <a href="/categories/%E6%97%85%E6%B8%B8/">
        <div class="categories-list-item">
          旅游
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/%E5%85%B6%E4%BB%96/">
        <div class="categories-list-item">
          其他
          <span class="categories-list-item-badge">11</span>
        </div>
      </a>
    
      <a href="/categories/%E6%B8%B8%E6%88%8F/">
        <div class="categories-list-item">
          游戏
          <span class="categories-list-item-badge">7</span>
        </div>
      </a>
    
      <a href="/categories/%E7%AE%97%E6%B3%95/">
        <div class="categories-list-item">
          算法
          <span class="categories-list-item-badge">7</span>
        </div>
      </a>
    
      <a href="/categories/%E8%80%83%E8%AF%95/">
        <div class="categories-list-item">
          考试
          <span class="categories-list-item-badge">8</span>
        </div>
      </a>
    
      <a href="/categories/%E9%98%85%E8%AF%BB/">
        <div class="categories-list-item">
          阅读
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
  </div>
</div>
  </article>
  
  <article class="card card-content tags-widget">
    <div class="tags-card">
  <div class="tags-header">
    <i 
      class="iconfont icon-biaoqian" 
      style="padding-right: 2px;">
    </i>热门标签
  </div>
  <div class="tags-list">
    
      <a 
        href="/tags/js/" 
        title="js">
        <div class="tags-list-item">js</div>
      </a>
    
      <a 
        href="/tags/vue/" 
        title="vue">
        <div class="tags-list-item">vue</div>
      </a>
    
      <a 
        href="/tags/%E9%9D%A2%E8%AF%95/" 
        title="面试">
        <div class="tags-list-item">面试</div>
      </a>
    
      <a 
        href="/tags/css/" 
        title="css">
        <div class="tags-list-item">css</div>
      </a>
    
      <a 
        href="/tags/%E7%BD%91%E7%BB%9C/" 
        title="网络">
        <div class="tags-list-item">网络</div>
      </a>
    
      <a 
        href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" 
        title="浏览器">
        <div class="tags-list-item">浏览器</div>
      </a>
    
      <a 
        href="/tags/%E5%85%B6%E4%BB%96/" 
        title="其他">
        <div class="tags-list-item">其他</div>
      </a>
    
      <a 
        href="/tags/%E7%AE%97%E6%B3%95/" 
        title="算法">
        <div class="tags-list-item">算法</div>
      </a>
    
      <a 
        href="/tags/html/" 
        title="html">
        <div class="tags-list-item">html</div>
      </a>
    
      <a 
        href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" 
        title="操作系统">
        <div class="tags-list-item">操作系统</div>
      </a>
    
      <a 
        href="/tags/%E8%80%83%E8%AF%95/" 
        title="考试">
        <div class="tags-list-item">考试</div>
      </a>
    
      <a 
        href="/tags/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/" 
        title="网络原理">
        <div class="tags-list-item">网络原理</div>
      </a>
    
      <a 
        href="/tags/%E5%8E%9F%E7%A5%9E/" 
        title="原神">
        <div class="tags-list-item">原神</div>
      </a>
    
      <a 
        href="/tags/DOM/" 
        title="DOM">
        <div class="tags-list-item">DOM</div>
      </a>
    
      <a 
        href="/tags/%E8%BD%AE%E5%AD%90/" 
        title="轮子">
        <div class="tags-list-item">轮子</div>
      </a>
    
      <a 
        href="/tags/debug/" 
        title="debug">
        <div class="tags-list-item">debug</div>
      </a>
    
  </div>
</div>
  </article>
  
  
</div>
            </aside>
            <main class="main-column">
              
<article class="card card-content">
  <header>
    <h1 class="post-title">
      axios如何利用promise无痛刷新token
    </h1>
  </header>
  <div class="post-meta post-show-meta">
    <a href="https://github.com/shuangxunian/shuangxunian.github.io/edit/server/source/_posts/22092624.md" target="_blank">编辑原文</a>
  </div>
  <div class="post-meta post-show-meta">
    <time datetime="2022-09-30T00:00:00.000Z">
      <i 
        class="iconfont icon-calendar" 
        style="margin-right: 2px;">
      </i>
      <span>2022-09-30</span>
    </time>
    
      <span class="dot"></span>
      
        <a 
          href="/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/" 
          class="post-meta-link">
          技术文章
        </a>
      
    
    
      <span class="dot"></span>
      <span>3.1k 字</span>
    
  </div>
  
    <div 
      class="post-meta post-show-meta" 
      style="margin-top: -10px;">
      <div style="display: flex; align-items: center;">
        <i 
          class="iconfont icon-biaoqian" 
          style="margin-right: 2px; font-size: 1.15rem;">
        </i>
        
          
          <a 
            href="/tags/js/" 
            class="post-meta-link">
            js
          </a>
        
          
            <span class="dot"></span>
          
          <a 
            href="/tags/axios/" 
            class="post-meta-link">
            axios
          </a>
        
      </div>
    </div>
  
  </header>
  <div 
    id="section" 
    class="post-content">
    <h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>最近遇到个需求：前端登录后，后端返回token和token有效时间，当token过期时要求用旧token去获取新的token，前端需要做到无痛刷新token，即请求刷新token时要做到用户无感知。</p>
<h2 id="需求解析"><a href="#需求解析" class="headerlink" title="需求解析"></a>需求解析</h2><p>当用户发起一个请求时，判断token是否已过期，若已过期则先调refreshToken接口，拿到新的token后再继续执行之前的请求。<br>这个问题的难点在于：当同时发起多个请求，而刷新token的接口还没返回，此时其他请求该如何处理？接下来会循序渐进地分享一下整个过程。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>由于后端返回了token的有效时间，可以有两种方法：</p>
<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>在请求发起前拦截每个请求，判断token的有效时间是否已经过期，若已过期，则将请求挂起，先刷新token后再继续请求。</p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>不在请求前拦截，而是拦截返回后的数据。先发起请求，接口返回过期后，先刷新token，再进行一次重试。</p>
<h2 id="两种方法对比"><a href="#两种方法对比" class="headerlink" title="两种方法对比"></a>两种方法对比</h2><h3 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h3><ul>
<li>优点： 在请求前拦截，能节省请求，省流量。</li>
<li>缺点： 需要后端额外提供一个token过期时间的字段；使用了本地时间判断，若本地时间被篡改，特别是本地时间比服务器时间慢时，拦截会失败。</li>
</ul>
<p>PS：token有效时间建议是时间段，类似缓存的MaxAge，而不要是绝对时间。当服务器和本地时间不一致时，绝对时间会有问题。</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-comment">// 从localStorage中获取token，token存的是object信息，有tokenExpireTime和token两个字段</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getToken</span> () &#123;<br>  <span class="hljs-keyword">let</span> tokenObj = &#123;&#125;<br>  <span class="hljs-keyword">try</span> &#123;<br>    tokenObj = storage.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;token&#x27;</span>)<br>    tokenObj = tokenObj ? <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(tokenObj) : &#123;&#125;<br>  &#125; <span class="hljs-keyword">catch</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;get token from localStorage error&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> tokenObj<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">refreshToken</span> () &#123;<br>    <span class="hljs-comment">// instance是当前request.js中已创建的axios实例</span><br>    <span class="hljs-keyword">return</span> instance.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/refreshtoken&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-property">data</span>)<br>&#125;<br><br><span class="hljs-comment">// 给实例添加一个setToken方法，用于登录后方便将最新token动态添加到header，同时将token保存在localStorage中</span><br>instance.<span class="hljs-property">setToken</span> = <span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> &#123;<br>  instance.<span class="hljs-property">defaults</span>.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;X-Token&#x27;</span>] = obj.<span class="hljs-property">token</span><br>  <span class="hljs-variable language_">window</span>.<span class="hljs-property">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;token&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj)) <span class="hljs-comment">// 注意这里需要变成字符串后才能放到localStorage中</span><br>&#125;<br><br>instance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> tokenObj = <span class="hljs-title function_">getToken</span>()<br>  <span class="hljs-comment">// 添加请求头</span><br>  config.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;X-Token&#x27;</span>] = tokenObj.<span class="hljs-property">token</span><br>  <span class="hljs-comment">// 登录接口和刷新token接口绕过</span><br>  <span class="hljs-keyword">if</span> (config.<span class="hljs-property">url</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;/rereshToken&#x27;</span>) &gt;= <span class="hljs-number">0</span> || config.<span class="hljs-property">url</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;/login&#x27;</span>) &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> config<br>  &#125;<br>  <span class="hljs-keyword">if</span> (tokenObj.<span class="hljs-property">token</span> &amp;&amp; tokenObj.<span class="hljs-property">tokenExpireTime</span>) &#123;<br>    <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br>    <span class="hljs-keyword">if</span> (now &gt;= tokenObj.<span class="hljs-property">tokenExpireTime</span>) &#123;<br>      <span class="hljs-comment">// 立即刷新token</span><br>      <span class="hljs-keyword">if</span> (!isRefreshing) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;刷新token ing&#x27;</span>)<br>        isRefreshing = <span class="hljs-literal">true</span><br>        <span class="hljs-title function_">refreshToken</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>          <span class="hljs-keyword">const</span> &#123; token, tokenExprieIn &#125; = res.<span class="hljs-property">data</span><br>          <span class="hljs-keyword">const</span> tokenExpireTime = now + tokenExprieIn * <span class="hljs-number">1000</span><br>          instance.<span class="hljs-title function_">setToken</span>(&#123; token, tokenExpireTime &#125;)<br>          isRefreshing = <span class="hljs-literal">false</span><br>          <span class="hljs-keyword">return</span> token<br>        &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">token</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;刷新token成功，执行队列&#x27;</span>)<br>          requests.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> <span class="hljs-title function_">cb</span>(token))<br>          <span class="hljs-comment">// 执行完成后，清空队列</span><br>          requests = []<br>        &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;refresh token error: &#x27;</span>, res)<br>        &#125;)<br>      &#125;<br>      <span class="hljs-keyword">const</span> retryOriginalRequest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>        requests.<span class="hljs-title function_">push</span>(<span class="hljs-function">(<span class="hljs-params">token</span>) =&gt;</span> &#123;<br>          <span class="hljs-comment">// 因为config中的token是旧的，所以刷新token后要将新token传进来</span><br>          config.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;X-Token&#x27;</span>] = token<br>          <span class="hljs-title function_">resolve</span>(config)<br>        &#125;)<br>      &#125;)<br>      <span class="hljs-keyword">return</span> retryOriginalRequest<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> config<br>&#125;, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// Do something with request error</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>&#125;)<br><br><span class="hljs-comment">// 请求返回后拦截</span><br>instance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123; code &#125; = response.<span class="hljs-property">data</span><br>  <span class="hljs-keyword">if</span> (code === <span class="hljs-number">1234</span>) &#123;<br>    <span class="hljs-comment">// token过期了，直接跳转到登录页 </span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-string">&#x27;/&#x27;</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> response<br>&#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;catch&#x27;</span>, error)<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> instance<br></code></pre>

<h3 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h3><ul>
<li>优点：不需额外的token过期字段，不需判断时间。</li>
<li>缺点： 会消耗多一次请求，耗流量。</li>
</ul>
<p>综上，方法一和二优缺点是互补的，方法一有校验失败的风险（本地时间被篡改时，当然一般没有用户闲的蛋疼去改本地时间的啦），方法二更简单粗暴，等知道服务器已经过期了再重试一次，只是会耗多一个请求。<br>在这里博主选择了 方法二。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这里会使用axios来实现，方法一是请求前拦截，所以会使用axios.interceptors.request.use()这个方法；</p>
<p>而方法二是请求后拦截，所以会使用axios.interceptors.response.use()方法。</p>
<h3 id="封装axios基本骨架"><a href="#封装axios基本骨架" class="headerlink" title="封装axios基本骨架"></a>封装axios基本骨架</h3><p>首先说明一下，项目中的token是存在localStorage中的。request.js基本骨架:</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-comment">// 从localStorage中获取token</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getLocalToken</span> () &#123;<br>    <span class="hljs-keyword">const</span> token = <span class="hljs-variable language_">window</span>.<span class="hljs-property">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;token&#x27;</span>)<br>    <span class="hljs-keyword">return</span> token<br>&#125;<br><br><br><span class="hljs-comment">// 给实例添加一个setToken方法，用于登录后将最新token动态添加到header，同时将token保存在localStorage中</span><br>instance.<span class="hljs-property">setToken</span> = <span class="hljs-function">(<span class="hljs-params">token</span>) =&gt;</span> &#123;<br>  instance.<span class="hljs-property">defaults</span>.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;X-Token&#x27;</span>] = token<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-property">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;token&#x27;</span>, token)<br>&#125;<br><br><span class="hljs-comment">// 创建一个axios实例</span><br><span class="hljs-keyword">const</span> instance = axios.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;/api&#x27;</span>,<br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">300000</span>,<br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,<br>    <span class="hljs-string">&#x27;X-Token&#x27;</span>: <span class="hljs-title function_">getLocalToken</span>() <span class="hljs-comment">// headers塞token</span><br>  &#125;<br>&#125;)<br><br><span class="hljs-comment">// 拦截返回的数据</span><br>instance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 接下来会在这里进行token过期的逻辑处理</span><br>  <span class="hljs-keyword">return</span> response<br>&#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> instance<br></code></pre>
<p>这个是项目中一般的axios实例的封装，创建实例时，将本地已有的token放进header，然后export出去供调用。接下来就是如何拦截返回的数据啦。</p>
<h3 id="instance-interceptors-response-use拦截实现"><a href="#instance-interceptors-response-use拦截实现" class="headerlink" title="instance.interceptors.response.use拦截实现"></a>instance.interceptors.response.use拦截实现</h3><p>后端接口一般会有一个约定好的数据结构，如：</p>
<pre class="highlight"><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  code<span class="hljs-punctuation">:</span> <span class="hljs-number">1234</span><span class="hljs-punctuation">,</span> <br>  message<span class="hljs-punctuation">:</span> &#x27;token过期&#x27;<span class="hljs-punctuation">,</span> <br>  data<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre>

<p>如我这里，后端约定当code &#x3D;&#x3D;&#x3D; 1234时表示token过期了，此时就要求刷新token。</p>
<pre class="highlight"><code class="hljs javascript">instance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123; code &#125; = response.<span class="hljs-property">data</span><br>  <span class="hljs-keyword">if</span> (code === <span class="hljs-number">1234</span>) &#123;<br>    <span class="hljs-comment">// 说明token过期了,刷新token</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">refreshToken</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>      <span class="hljs-comment">// 刷新token成功，将最新的token更新到header中，同时保存在localStorage中</span><br>      <span class="hljs-keyword">const</span> &#123; token &#125; = res.<span class="hljs-property">data</span><br>      instance.<span class="hljs-title function_">setToken</span>(token)<br>      <span class="hljs-comment">// 获取当前失败的请求</span><br>      <span class="hljs-keyword">const</span> config = response.<span class="hljs-property">config</span><br>      <span class="hljs-comment">// 重置一下配置</span><br>      config.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;X-Token&#x27;</span>] = token<br>      config.<span class="hljs-property">baseURL</span> = <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// url已经带上了/api，避免出现/api/api的情况</span><br>      <span class="hljs-comment">// 重试当前请求并返回promise</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">instance</span>(config)<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;refreshtoken error =&gt;&#x27;</span>, res)<br>      <span class="hljs-comment">//刷新token失败，神仙也救不了了，跳转到首页重新登录吧</span><br>      <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-string">&#x27;/&#x27;</span><br>    &#125;)<br>  &#125;<br>  <span class="hljs-keyword">return</span> response<br>&#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>&#125;)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">refreshToken</span> () &#123;<br>    <span class="hljs-comment">// instance是当前request.js中已创建的axios实例</span><br>    <span class="hljs-keyword">return</span> instance.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/refreshtoken&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-property">data</span>)<br>&#125;<br></code></pre>

<p>这里需要额外注意的是，response.config就是原请求的配置，但这个是已经处理过了的，config.url已经带上了baseUrl，因此重试时需要去掉，同时token也是旧的，需要刷新下。</p>
<p>以上就基本做到了无痛刷新token，当token正常时，正常返回，当token已过期，则axios内部进行一次刷新token和重试。对调用者来说，axios内部的刷新token是一个黑盒，是无感知的，因此需求已经做到了。</p>
<h2 id="问题和优化"><a href="#问题和优化" class="headerlink" title="问题和优化"></a>问题和优化</h2><p>上面的代码还是存在一些问题的，没有考虑到多次请求的问题，因此需要进一步优化。</p>
<h3 id="如何防止多次刷新token"><a href="#如何防止多次刷新token" class="headerlink" title="如何防止多次刷新token"></a>如何防止多次刷新token</h3><p>如果refreshToken接口还没返回，此时再有一个过期的请求进来，上面的代码就会再一次执行refreshToken，这就会导致多次执行刷新token的接口，因此需要防止这个问题。我们可以在request.js中用一个flag来标记当前是否正在刷新token的状态，如果正在刷新则不再调用刷新token的接口。</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// 是否正在刷新的标记</span><br><span class="hljs-keyword">let</span> isRefreshing = <span class="hljs-literal">false</span><br>instance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123; code &#125; = response.<span class="hljs-property">data</span><br>  <span class="hljs-keyword">if</span> (code === <span class="hljs-number">1234</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!isRefreshing) &#123;<br>      isRefreshing = <span class="hljs-literal">true</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">refreshToken</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> &#123; token &#125; = res.<span class="hljs-property">data</span><br>        instance.<span class="hljs-title function_">setToken</span>(token)<br>        <span class="hljs-keyword">const</span> config = response.<span class="hljs-property">config</span><br>        config.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;X-Token&#x27;</span>] = token<br>        config.<span class="hljs-property">baseURL</span> = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">instance</span>(config)<br>      &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;refreshtoken error =&gt;&#x27;</span>, res)<br>        <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-string">&#x27;/&#x27;</span><br>      &#125;).<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        isRefreshing = <span class="hljs-literal">false</span><br>      &#125;)<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> response<br>&#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>&#125;)<br></code></pre>

<p>这样子就可以避免在刷新token时再进入方法了。但是这种做法是相当于把其他失败的接口给舍弃了，假如同时发起两个请求，且几乎同时返回，第一个请求肯定是进入了refreshToken后再重试，而第二个请求则被丢弃了，仍是返回失败，所以接下来还得解决其他接口的重试问题。</p>
<h3 id="同时发起两个或以上的请求时，其他接口如何重试"><a href="#同时发起两个或以上的请求时，其他接口如何重试" class="headerlink" title="同时发起两个或以上的请求时，其他接口如何重试"></a>同时发起两个或以上的请求时，其他接口如何重试</h3><p>两个接口几乎同时发起和返回，第一个接口会进入刷新token后重试的流程，而第二个接口需要先存起来，然后等刷新token后再重试。同样，如果同时发起三个请求，此时需要缓存后两个接口，等刷新token后再重试。由于接口都是异步的，处理起来会有点麻烦。</p>
<p>当第二个过期的请求进来，token正在刷新，我们先将这个请求存到一个数组队列中，想办法让这个请求处于等待中，一直等到刷新token后再逐个重试清空请求队列。<br>那么如何做到让这个请求处于等待中呢？为了解决这个问题，我们得借助Promise。将请求存进队列中后，同时返回一个Promise，让这个Promise一直处于Pending状态（即不调用resolve），此时这个请求就会一直等啊等，只要我们不执行resolve，这个请求就会一直在等待。当刷新请求的接口返回来后，我们再调用resolve，逐个重试。最终代码：</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// 是否正在刷新的标记</span><br><span class="hljs-keyword">let</span> isRefreshing = <span class="hljs-literal">false</span><br><span class="hljs-comment">// 重试队列，每一项将是一个待执行的函数形式</span><br><span class="hljs-keyword">let</span> requests = []<br><br>instance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123; code &#125; = response.<span class="hljs-property">data</span><br>  <span class="hljs-keyword">if</span> (code === <span class="hljs-number">1234</span>) &#123;<br>    <span class="hljs-keyword">const</span> config = response.<span class="hljs-property">config</span><br>    <span class="hljs-keyword">if</span> (!isRefreshing) &#123;<br>      isRefreshing = <span class="hljs-literal">true</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">refreshToken</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> &#123; token &#125; = res.<span class="hljs-property">data</span><br>        instance.<span class="hljs-title function_">setToken</span>(token)<br>        config.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;X-Token&#x27;</span>] = token<br>        config.<span class="hljs-property">baseURL</span> = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-comment">// 已经刷新了token，将所有队列中的请求进行重试</span><br>        requests.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> <span class="hljs-title function_">cb</span>(token))<br>        <span class="hljs-comment">// 重试完了别忘了清空这个队列（掘金评论区同学指点）</span><br>        requests = []<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">instance</span>(config)<br>      &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;refreshtoken error =&gt;&#x27;</span>, res)<br>        <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-string">&#x27;/&#x27;</span><br>      &#125;).<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        isRefreshing = <span class="hljs-literal">false</span><br>      &#125;)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 正在刷新token，返回一个未执行resolve的promise</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 将resolve放进队列，用一个函数形式来保存，等token刷新后直接执行</span><br>        requests.<span class="hljs-title function_">push</span>(<span class="hljs-function">(<span class="hljs-params">token</span>) =&gt;</span> &#123;<br>          config.<span class="hljs-property">baseURL</span> = <span class="hljs-string">&#x27;&#x27;</span><br>          config.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;X-Token&#x27;</span>] = token<br>          <span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">instance</span>(config))<br>        &#125;)<br>      &#125;)<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> response<br>&#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>&#125;)<br></code></pre>

<p>这里可能比较难理解的是requests这个队列中保存的是一个函数，这是为了让resolve不执行，先存起来，等刷新token后更方便调用这个函数使得resolve执行。至此，问题应该都解决了。</p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-comment">// 从localStorage中获取token</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getLocalToken</span> () &#123;<br>    <span class="hljs-keyword">const</span> token = <span class="hljs-variable language_">window</span>.<span class="hljs-property">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;token&#x27;</span>)<br>    <span class="hljs-keyword">return</span> token<br>&#125;<br><br><span class="hljs-comment">// 给实例添加一个setToken方法，用于登录后将最新token动态添加到header，同时将token保存在localStorage中</span><br>instance.<span class="hljs-property">setToken</span> = <span class="hljs-function">(<span class="hljs-params">token</span>) =&gt;</span> &#123;<br>  instance.<span class="hljs-property">defaults</span>.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;X-Token&#x27;</span>] = token<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-property">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;token&#x27;</span>, token)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">refreshToken</span> () &#123;<br>    <span class="hljs-comment">// instance是当前request.js中已创建的axios实例</span><br>    <span class="hljs-keyword">return</span> instance.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/refreshtoken&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-property">data</span>)<br>&#125;<br><br><span class="hljs-comment">// 创建一个axios实例</span><br><span class="hljs-keyword">const</span> instance = axios.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;/api&#x27;</span>,<br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">300000</span>,<br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,<br>    <span class="hljs-string">&#x27;X-Token&#x27;</span>: <span class="hljs-title function_">getLocalToken</span>() <span class="hljs-comment">// headers塞token</span><br>  &#125;<br>&#125;)<br><br><span class="hljs-comment">// 是否正在刷新的标记</span><br><span class="hljs-keyword">let</span> isRefreshing = <span class="hljs-literal">false</span><br><span class="hljs-comment">// 重试队列，每一项将是一个待执行的函数形式</span><br><span class="hljs-keyword">let</span> requests = []<br><br>instance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123; code &#125; = response.<span class="hljs-property">data</span><br>  <span class="hljs-keyword">if</span> (code === <span class="hljs-number">1234</span>) &#123;<br>    <span class="hljs-keyword">const</span> config = response.<span class="hljs-property">config</span><br>    <span class="hljs-keyword">if</span> (!isRefreshing) &#123;<br>      isRefreshing = <span class="hljs-literal">true</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">refreshToken</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> &#123; token &#125; = res.<span class="hljs-property">data</span><br>        instance.<span class="hljs-title function_">setToken</span>(token)<br>        config.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;X-Token&#x27;</span>] = token<br>        config.<span class="hljs-property">baseURL</span> = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-comment">// 已经刷新了token，将所有队列中的请求进行重试</span><br>        requests.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> <span class="hljs-title function_">cb</span>(token))<br>        requests = []<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">instance</span>(config)<br>      &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;refreshtoken error =&gt;&#x27;</span>, res)<br>        <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-string">&#x27;/&#x27;</span><br>      &#125;).<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        isRefreshing = <span class="hljs-literal">false</span><br>      &#125;)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 正在刷新token，将返回一个未执行resolve的promise</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 将resolve放进队列，用一个函数形式来保存，等token刷新后直接执行</span><br>        requests.<span class="hljs-title function_">push</span>(<span class="hljs-function">(<span class="hljs-params">token</span>) =&gt;</span> &#123;<br>          config.<span class="hljs-property">baseURL</span> = <span class="hljs-string">&#x27;&#x27;</span><br>          config.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;X-Token&#x27;</span>] = token<br>          <span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">instance</span>(config))<br>        &#125;)<br>      &#125;)<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> response<br>&#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> instance<br></code></pre>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903925078818829">axios如何利用promise无痛刷新token</a></p>

  </div>
  <div>
    
  </div>
</article>
<div class="nav">
  
    <div class="nav-item-prev">
      <a 
        href="/2022/09/30/22092623/" 
        class="nav-link">
        <i class="iconfont icon-left nav-prev-icon"></i>
        <div>
          <div class="nav-label">上一篇</div>
          
            <div class="nav-title">智能推荐算法综述 </div>
          
        </div>
      </a>
    </div>
  
  
    <div class="nav-item-next">
      <a 
        href="/2022/09/30/22092625/" 
        class="nav-link">
        <div>
          <div class="nav-label">下一篇</div>
          
            <div class="nav-title">Vue的computed和watch的细节全面分析 </div>
          
        </div>
        <i class="iconfont icon-right nav-next-icon"></i>
      </a>
    </div>
  
</div>

<div 
  class="card card-content toc-card" 
  id="mobiletoc">
  <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>目录
</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82"><span class="toc-text">需求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E8%A7%A3%E6%9E%90"><span class="toc-text">需求解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-text">实现思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80"><span class="toc-text">方法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C"><span class="toc-text">方法二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="toc-text">两种方法对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80-1"><span class="toc-text">方法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C-1"><span class="toc-text">方法二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85axios%E5%9F%BA%E6%9C%AC%E9%AA%A8%E6%9E%B6"><span class="toc-text">封装axios基本骨架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instance-interceptors-response-use%E6%8B%A6%E6%88%AA%E5%AE%9E%E7%8E%B0"><span class="toc-text">instance.interceptors.response.use拦截实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%92%8C%E4%BC%98%E5%8C%96"><span class="toc-text">问题和优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%A4%9A%E6%AC%A1%E5%88%B7%E6%96%B0token"><span class="toc-text">如何防止多次刷新token</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E5%8F%91%E8%B5%B7%E4%B8%A4%E4%B8%AA%E6%88%96%E4%BB%A5%E4%B8%8A%E7%9A%84%E8%AF%B7%E6%B1%82%E6%97%B6%EF%BC%8C%E5%85%B6%E4%BB%96%E6%8E%A5%E5%8F%A3%E5%A6%82%E4%BD%95%E9%87%8D%E8%AF%95"><span class="toc-text">同时发起两个或以上的请求时，其他接口如何重试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-text">完整代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-text">参考链接</span></a></li></ol>
</div>

            </main>
            <aside class="right-column">
              <div class="sticky-widescreen">
  
  
    <article class="card card-content toc-card">
      <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>目录
</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82"><span class="toc-text">需求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E8%A7%A3%E6%9E%90"><span class="toc-text">需求解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-text">实现思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80"><span class="toc-text">方法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C"><span class="toc-text">方法二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="toc-text">两种方法对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80-1"><span class="toc-text">方法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C-1"><span class="toc-text">方法二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85axios%E5%9F%BA%E6%9C%AC%E9%AA%A8%E6%9E%B6"><span class="toc-text">封装axios基本骨架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instance-interceptors-response-use%E6%8B%A6%E6%88%AA%E5%AE%9E%E7%8E%B0"><span class="toc-text">instance.interceptors.response.use拦截实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%92%8C%E4%BC%98%E5%8C%96"><span class="toc-text">问题和优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%A4%9A%E6%AC%A1%E5%88%B7%E6%96%B0token"><span class="toc-text">如何防止多次刷新token</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E5%8F%91%E8%B5%B7%E4%B8%A4%E4%B8%AA%E6%88%96%E4%BB%A5%E4%B8%8A%E7%9A%84%E8%AF%B7%E6%B1%82%E6%97%B6%EF%BC%8C%E5%85%B6%E4%BB%96%E6%8E%A5%E5%8F%A3%E5%A6%82%E4%BD%95%E9%87%8D%E8%AF%95"><span class="toc-text">同时发起两个或以上的请求时，其他接口如何重试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-text">完整代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-text">参考链接</span></a></li></ol>
    </article>
  
  
  <article class="card card-content">
    <div class="recent-posts-card">
  <div class="recent-posts-header">
    <i 
      class="iconfont icon-wenzhang_huaban" 
      style="padding-right: 2px;">
    </i>最近文章
  </div>
  <div class="recent-posts-list">
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-11-06</div>
        <a href="/2022/11/06/22101701/"><div class="recent-posts-item-content">关于玩原神需要掌握的学科</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-10-30</div>
        <a href="/2022/10/30/22103001/"><div class="recent-posts-item-content">弹性盒子上下布局</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-10-21</div>
        <a href="/2022/10/21/22102101/"><div class="recent-posts-item-content">《普通破盾学》(正式版)</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-10-21</div>
        <a href="/2022/10/21/22102102/"><div class="recent-posts-item-content">伤害乘区论</div></a>
      </div>
    
  </div>
</div>
  </article>
  
  
  <article class="card card-content">
    <h1 style="padding-bottom: 12px;">关注嘉然！顿顿解馋！</h1>
    <img src="https://api2.mubu.com/v3/document_image/2697c6ae-10ee-41a3-9099-304bdb252d31-3807603.jpg">
  </article>
</div>
            </aside>
          </div>
        </div>
      </div>
    </div>
     
    <footer class="footer">
  <div class="footer-container">
    <div>
      <div class="footer-dsc">
        <span>
          Copyright ©
          
            2020
          
          
                - 
                2022
          
        </span>
        &nbsp;
        <a 
          href="/" 
          class="footer-link">
          霜序廿的个人网站
        </a>
      </div>
    </div>

    
      <div class="footer-dsc">
        
          Powered by
          <a 
            href="https://hexo.io/" 
            class="footer-link" 
            target="_blank" 
            rel="nofollow noopener noreferrer">
            &nbsp;Hexo
          </a>
        
        
          <span>&nbsp;|&nbsp;</span>
        
        
          Theme -
          <a 
            href="https://github.com/theme-kaze" 
            class="footer-link" 
            target="_blank"
            rel="nofollow noopener noreferrer">
            &nbsp;Kaze
          </a>
        
      </div>
    
    
    
    
</footer>
 
    
  <a 
    role="button" 
    id="scrollbutton" 
    class="basebutton" 
    aria-label="回到顶部">
    <i class="iconfont icon-arrowleft button-icon"></i>
  </a>

<a 
  role="button" 
  id="menubutton"
  aria-label="menu button"
  class="basebutton">
  <i class="iconfont icon-menu button-icon"></i>
</a>
<a 
  role="button" 
  id="popbutton" 
  class="basebutton" 
  aria-label="控制中心">
  <i class="iconfont icon-expand button-icon"></i>
</a>
<a 
  role="button" 
  id="darkbutton" 
  class="basebutton darkwidget" 
  aria-label="夜色模式">
  <i class="iconfont icon-weather button-icon"></i>
</a>
<a 
  role="button" 
  id="searchbutton" 
  class="basebutton searchwidget" 
  aria-label="搜索">
  <i class="iconfont icon-search button-icon"></i>
</a> 
     
     
     
      <script>
  var addImgLayout = function () {
    var img = document.querySelectorAll('.post-content img')
    var i
    for (i = 0; i < img.length; i++) {
      var wrapper = document.createElement('a')
      wrapper.setAttribute('href', img[i].getAttribute('data-src'))
      wrapper.setAttribute('aria-label', 'illustration')
      wrapper.style.cssText =
        'width: 100%; display: flex; justify-content: center;'
      if (img[i].alt) wrapper.dataset.caption = img[i].alt
      wrapper.dataset.nolink = true
      img[i].before(wrapper)
      wrapper.append(img[i])
      var divWrap = document.createElement('div')
      divWrap.classList.add('gallery')
      wrapper.before(divWrap)
      divWrap.append(wrapper)
    }
    baguetteBox.run('.gallery')
  }
</script>
<script>
  loadScript(
    "/js/lib/lightbox/baguetteBox.min.js",
    addImgLayout
  )
</script>
 
     
     
    <script src="/js/main.js"></script> 
     
    
      <script>
        var addLazyload = function () {
          var observer = lozad('.lozad', {
            load: function (el) {
              el.srcset = el.getAttribute('data-src')
            },
            loaded: function (el) {
              el.classList.add('loaded')
            },
          })
          observer.observe()
        }
      </script>
      <script>
        loadScript('/js/lib/lozad.min.js', addLazyload)
      </script>
    
    <script src="//instant.page/5.1.0" type="module"
      integrity="sha384-by67kQnR+pyfy8yWP4kPO12fHKRLHZPfEsiSXR8u2IKcTdxD805MGUXBzVPnkLHw"></script>
    
    
  </body>
</html>
