<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta charset="UTF-8">
  <meta 
    name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta 
    http-equiv="X-UA-Compatible" 
    content="ie=edge">
  <meta 
    name="theme-color" 
    content="#fff" 
    id="theme-color">
  <meta 
    name="description" 
    content="记录个人成长与生活，前端，算法，nlp">
  <link 
    rel="icon" 
    href="https://q2.qlogo.cn/headimg_dl?dst_uin=2749909223&amp;spec=5">
  <title>手摸手带你理解Vue响应式原理</title>
  
    
      <meta 
        property="og:title" 
        content="手摸手带你理解Vue响应式原理">
    
    
      <meta 
        property="og:url" 
        content="http://example.com/2022/09/30/22092803/index.html">
    
    
      <meta 
        property="og:img" 
        content="https://q2.qlogo.cn/headimg_dl?dst_uin=2749909223&amp;spec=5">
    
    
      <meta 
        property="og:img" 
        content="如题目">
    
    
      <meta 
        property="og:type" 
        content="article">
      <meta 
        property="og:article:published_time" 
        content="2022-09-30">
      <meta 
        property="og:article:modified_time" 
        content="2022-09-30">
      <meta 
        property="og:article:author" 
        content="霜序廿">
      
        
          <meta 
            property="og:article:tag" 
            content="js">
        
          <meta 
            property="og:article:tag" 
            content="vue">
        
      
    
  
  
  <link rel="preload" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css" as="style" >
  <link rel="preload" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css" as="style" >
  <link rel="preload" href="/css/main.css" as="style" >
  
  <link rel="modulepreload" href="//instant.page/5.1.0">
  
  <link rel="stylesheet" href="/css/main.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css">
  
  
  
    <link rel="stylesheet" href="/js/lib/lightbox/baguetteBox.min.css">
  
  <script>
    function loadScript(url, cb) {
      var script = document.createElement('script');
      script.src = url;
      if (cb) script.onload = cb;
      script.async = true;
      document.body.appendChild(script);
    }
    function loadCSS(href, data, attr) {
      var sheet = document.createElement('link');
      sheet.ref = 'stylesheet';
      sheet.href = href;
      sheet.dataset[data] = attr;
      document.head.appendChild(sheet);
    }
    function changeCSS(cssFile, data, attr) {
      var oldlink = document.querySelector(data);
      var newlink = document.createElement("link");
      newlink.setAttribute("rel", "stylesheet");
      newlink.setAttribute("href", cssFile);
      newlink.dataset.prism = attr;
      document.head.replaceChild(newlink, oldlink);
    }
  </script>
  
    
  
  <script>
    // control reverse button
    var reverseDarkList = {
      dark: 'light',
      light: 'dark'
    };
    var themeColor = {
      dark: '#1c1c1e',
      light: '#fff'
    }
    // get the data of css prefers-color-scheme
    var getCssMediaQuery = function() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };
    // reverse current darkmode setting function
    var reverseDarkModeSetting = function() {
      var setting = localStorage.getItem('user-color-scheme');
      if(reverseDarkList[setting]) {
        setting = reverseDarkList[setting];
      } else if(setting === null) {
        setting = reverseDarkList[getCssMediaQuery()];
      } else {
        return;
      }
      localStorage.setItem('user-color-scheme', setting);
      return setting;
    };
    // apply current darkmode setting
  </script>
  
    <script>
      var setDarkmode = function(mode) {
      var setting = mode || localStorage.getItem('user-color-scheme');
      if(setting === getCssMediaQuery()) {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[setting];
        document.getElementById('theme-color').dataset.mode = setting;
      } else if(reverseDarkList[setting]) {
        document.documentElement.setAttribute('data-user-color-scheme', setting);
        document.getElementById('theme-color').content = themeColor[setting];
        document.getElementById('theme-color').dataset.mode = setting;
      } else {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[getCssMediaQuery()];
        document.getElementById('theme-color').dataset.mode = getCssMediaQuery();
      }
    };
    setDarkmode();
    </script>
  
  
  
    <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.js" as="script">
    <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.css" as="style" >
  
  
    <link rel="preload" href="/js/lib/lozad.min.js" as="script">
  
  
  
  
  
  
<meta name="generator" content="Hexo 6.3.0"></head>

  <body>
    <div class="wrapper">
       
      <nav class="navbar">
  <div class="navbar-logo">
    <a class="navbar-logo-main" href="/">
      
        <img 
          class="navbar-logo-img"
          width="32"
          height="32"
          src="https://q2.qlogo.cn/headimg_dl?dst_uin=2749909223&spec=5" 
          alt="blog logo">
      
      <span class="navbar-logo-dsc">霜序廿的个人网站</span>
      </a>
  </div>
  <div class="navbar-menu">
    
      <a 
        href="/" 
        class="navbar-menu-item">
        
          首页
        
      </a>
    
      <a 
        href="/archives" 
        class="navbar-menu-item">
        
          归档
        
      </a>
    
      <a 
        href="/tags" 
        class="navbar-menu-item">
        
          标签
        
      </a>
    
      <a 
        href="/categories" 
        class="navbar-menu-item">
        
          分类
        
      </a>
    
      <a 
        href="/about" 
        class="navbar-menu-item">
        
          关于
        
      </a>
    
      <a 
        href="/links" 
        class="navbar-menu-item">
        
          友链
        
      </a>
    
    <button 
      class="navbar-menu-item darknavbar navbar-menu-btn" 
      aria-label="Toggle dark mode"
      id="dark">
      <i class="iconfont icon-weather"></i>
    </button>
    <button 
      class="navbar-menu-item searchnavbar navbar-menu-btn" 
      aria-label="Toggle search"
      id="search">
      <!-- <i 
        class="iconfont icon-search" 
        style="font-size: 1.2rem; font-weight: 400;">
      </i> -->
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img"
        class="iconify iconify--ion" width="28" height="28" preserveAspectRatio="xMidYMid meet" viewBox="0 0 512 512">
        <path fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="28"
          d="M256 80a176 176 0 1 0 176 176A176 176 0 0 0 256 80Z"></path>
        <path fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="28"
          d="M232 160a72 72 0 1 0 72 72a72 72 0 0 0-72-72Z"></path>
        <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="28"
          d="M283.64 283.64L336 336"></path>
      </svg>
    </button>
  </div>
</nav> 
      
      <div 
        id="local-search" 
        style="display: none">
        <input
          class="navbar-menu-item"
          id="search-input"
          placeholder="请输入搜索内容..." />
        <div id="search-content"></div>
      </div>
      
      <div class="section-wrap">
        <div class="container">
          <div class="columns">
            <aside class="left-column">
              
              <div class="card card-author">
                
  <img 
    src="https://q2.qlogo.cn/headimg_dl?dst_uin=2749909223&spec=5" 
    class="author-img"
    width="88"
    height="88"
    alt="author avatar">

<p class="author-name">霜序廿</p>
<p class="author-description">一个爱算法的小前端</p>
<div class="author-message">
  <a 
    class="author-posts-count" 
    href="/archives">
    <span>270</span>
    <span>文章</span>
  </a>
  <a 
    class="author-categories-count" 
    href="/categories">
    <span>7</span>
    <span>分类</span>
  </a>
  <a 
    class="author-tags-count" 
    href="/tags">
    <span>54</span>
    <span>标签</span>
  </a>
</div>

  <div class="author-card-society">
    
      <div class="author-card-society-icon">
        <a target="_blank" rel="noopener" href="https://github.com/shuangxunian">
          <i class="iconfont icon-github society-icon"></i>
        </a>
      </div>
    
      <div class="author-card-society-icon">
        <a target="_blank" rel="noopener" href="https://space.bilibili.com/391117803">
          <i class="iconfont icon-bilibili society-icon"></i>
        </a>
      </div>
    
  </div>

              </div>
               <div class="sticky-tablet">
  
  
    <article class="display-when-two-columns spacer">
      <div class="card card-content toc-card">
        <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>目录
</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%88%90%E5%91%98"><span class="toc-text">主要成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Observe%EF%BC%9A%E6%88%91%E4%BC%9A%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E8%A7%82%E6%B5%8B"><span class="toc-text">Observe：我会对数据进行观测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dep%EF%BC%9A%E6%88%91%E4%BC%9A%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E4%BE%9D%E8%B5%96"><span class="toc-text">Dep：我会为数据收集依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Watcher%EF%BC%9A%E6%88%91%E4%BC%9A%E8%A7%A6%E5%8F%91%E8%A7%86%E5%9B%BE%E6%9B%B4%E6%96%B0"><span class="toc-text">Watcher：我会触发视图更新</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-text">响应式原理流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A7%82%E6%B5%8B"><span class="toc-text">数据观测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%A7%82%E6%B5%8B"><span class="toc-text">对象观测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%A7%82%E6%B5%8B"><span class="toc-text">数组观测</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-text">数组方法重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86"><span class="toc-text">依赖收集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B"><span class="toc-text">伪代码流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9C%9F%E6%AD%A3%E6%B5%81%E7%A8%8B"><span class="toc-text">真正流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86"><span class="toc-text">数组的依赖收集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-text">整体流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-text">初始化流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6%EF%BC%9A"><span class="toc-text">入口文件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#init%EF%BC%9A"><span class="toc-text">_init：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#initState%EF%BC%9A"><span class="toc-text">initState：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mount"><span class="toc-text">$mount:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mountComponent"><span class="toc-text">mountComponent:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Watcher"><span class="toc-text">Watcher:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B"><span class="toc-text">更新流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#wathcer-update%EF%BC%9A"><span class="toc-text">wathcer.update：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queueWatcher"><span class="toc-text">queueWatcher:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nextTick%EF%BC%9A"><span class="toc-text">nextTick：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E"><span class="toc-text">写在最后</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-text">参考链接</span></a></li></ol>
      </div>
    </article>
  
  
  <article class="card card-content categories-widget">
    <div class="categories-card">
  <div class="categories-header">
    <i 
      class="iconfont icon-fenlei" 
      style="padding-right: 2px;">
    </i>分类
  </div>
  <div class="categories-list">
    
      <a href="/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/">
        <div class="categories-list-item">
          技术文章
          <span class="categories-list-item-badge">234</span>
        </div>
      </a>
    
      <a href="/categories/%E6%97%85%E6%B8%B8/">
        <div class="categories-list-item">
          旅游
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/%E5%85%B6%E4%BB%96/">
        <div class="categories-list-item">
          其他
          <span class="categories-list-item-badge">11</span>
        </div>
      </a>
    
      <a href="/categories/%E6%B8%B8%E6%88%8F/">
        <div class="categories-list-item">
          游戏
          <span class="categories-list-item-badge">8</span>
        </div>
      </a>
    
      <a href="/categories/%E7%AE%97%E6%B3%95/">
        <div class="categories-list-item">
          算法
          <span class="categories-list-item-badge">7</span>
        </div>
      </a>
    
      <a href="/categories/%E8%80%83%E8%AF%95/">
        <div class="categories-list-item">
          考试
          <span class="categories-list-item-badge">8</span>
        </div>
      </a>
    
      <a href="/categories/%E9%98%85%E8%AF%BB/">
        <div class="categories-list-item">
          阅读
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
  </div>
</div>
  </article>
  
  <article class="card card-content tags-widget">
    <div class="tags-card">
  <div class="tags-header">
    <i 
      class="iconfont icon-biaoqian" 
      style="padding-right: 2px;">
    </i>热门标签
  </div>
  <div class="tags-list">
    
      <a 
        href="/tags/js/" 
        title="js">
        <div class="tags-list-item">js</div>
      </a>
    
      <a 
        href="/tags/vue/" 
        title="vue">
        <div class="tags-list-item">vue</div>
      </a>
    
      <a 
        href="/tags/css/" 
        title="css">
        <div class="tags-list-item">css</div>
      </a>
    
      <a 
        href="/tags/%E9%9D%A2%E8%AF%95/" 
        title="面试">
        <div class="tags-list-item">面试</div>
      </a>
    
      <a 
        href="/tags/%E7%BD%91%E7%BB%9C/" 
        title="网络">
        <div class="tags-list-item">网络</div>
      </a>
    
      <a 
        href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" 
        title="浏览器">
        <div class="tags-list-item">浏览器</div>
      </a>
    
      <a 
        href="/tags/%E5%85%B6%E4%BB%96/" 
        title="其他">
        <div class="tags-list-item">其他</div>
      </a>
    
      <a 
        href="/tags/%E7%AE%97%E6%B3%95/" 
        title="算法">
        <div class="tags-list-item">算法</div>
      </a>
    
      <a 
        href="/tags/html/" 
        title="html">
        <div class="tags-list-item">html</div>
      </a>
    
      <a 
        href="/tags/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/" 
        title="网络原理">
        <div class="tags-list-item">网络原理</div>
      </a>
    
      <a 
        href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" 
        title="操作系统">
        <div class="tags-list-item">操作系统</div>
      </a>
    
      <a 
        href="/tags/%E8%80%83%E8%AF%95/" 
        title="考试">
        <div class="tags-list-item">考试</div>
      </a>
    
      <a 
        href="/tags/%E5%8E%9F%E7%A5%9E/" 
        title="原神">
        <div class="tags-list-item">原神</div>
      </a>
    
      <a 
        href="/tags/%E8%BD%AF%E5%AE%9E%E5%8A%9B/" 
        title="软实力">
        <div class="tags-list-item">软实力</div>
      </a>
    
      <a 
        href="/tags/DOM/" 
        title="DOM">
        <div class="tags-list-item">DOM</div>
      </a>
    
      <a 
        href="/tags/%E8%BD%AE%E5%AD%90/" 
        title="轮子">
        <div class="tags-list-item">轮子</div>
      </a>
    
  </div>
</div>
  </article>
  
  
</div>
            </aside>
            <main class="main-column">
              
<article class="card card-content">
  <header>
    <h1 class="post-title">
      手摸手带你理解Vue响应式原理
    </h1>
  </header>
  
    <div class="post-meta post-show-meta">
      <a href="/edit/server/source/_posts/22092803.md" target="_blank">编辑原文</a>
    </div>
  
  <div class="post-meta post-show-meta">
    <time datetime="2022-09-30T00:00:00.000Z">
      <i 
        class="iconfont icon-calendar" 
        style="margin-right: 2px;">
      </i>
      <span>2022-09-30</span>
    </time>
    
      <span class="dot"></span>
      
        <a 
          href="/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/" 
          class="post-meta-link">
          技术文章
        </a>
      
    
    
      <span class="dot"></span>
      <span>5k 字</span>
    
  </div>
  
    <div 
      class="post-meta post-show-meta" 
      style="margin-top: -10px;">
      <div style="display: flex; align-items: center;">
        <i 
          class="iconfont icon-biaoqian" 
          style="margin-right: 2px; font-size: 1.15rem;">
        </i>
        
          
          <a 
            href="/tags/js/" 
            class="post-meta-link">
            js
          </a>
        
          
            <span class="dot"></span>
          
          <a 
            href="/tags/vue/" 
            class="post-meta-link">
            vue
          </a>
        
      </div>
    </div>
  
  </header>
  <div 
    id="section" 
    class="post-content">
    <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>响应式原理作为 Vue 的核心，使用数据劫持实现数据驱动视图。在面试中是经常考查的知识点，也是面试加分项。</p>
<p>本文将会循序渐进的解析响应式原理的工作流程，主要以下面结构进行：</p>
<ol>
<li>分析主要成员，了解它们有助于理解流程</li>
<li>将流程拆分，理解其中的作用</li>
<li>结合以上的点，理解整体流程</li>
</ol>
<p>文章稍长，但部分是代码，还请耐心观看。为了方便理解原理，文中的代码会进行简化，如果可以请对照源码学习。</p>
<h2 id="主要成员"><a href="#主要成员" class="headerlink" title="主要成员"></a>主要成员</h2><p>在响应式原理中，Observe、Dep、Watcher 这三个类是构成完整原理的主要成员。</p>
<ul>
<li>Observe，响应式原理的入口，根据数据类型处理观测逻辑</li>
<li>Dep，依赖收集器，属性都会有一个Dep，方便发生变化时能够找到对应的依赖触发更新</li>
<li>Watcher，用于执行更新渲染，组件会拥有一个渲染Watcher，我们常说的收集依赖，就是收集 Watcher</li>
</ul>
<p>下面来看看这些类的实现，包含哪些主要属性和方法。</p>
<h3 id="Observe：我会对数据进行观测"><a href="#Observe：我会对数据进行观测" class="headerlink" title="Observe：我会对数据进行观测"></a>Observe：我会对数据进行观测</h3><p>温馨提示：代码里的序号对应代码块下面序号的讲解</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// 源码位置：/src/core/observer/index.js</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observe</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dep</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>()<br>    <span class="hljs-comment">// 1</span><br>    <span class="hljs-title function_">def</span>(data, <span class="hljs-string">&#x27;__ob__&#x27;</span>, <span class="hljs-variable language_">this</span>)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(data)) &#123;<br>      <span class="hljs-comment">// 2</span><br>      <span class="hljs-title function_">protoAugment</span>(data, arrayMethods)<br>      <span class="hljs-comment">// 3</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">observeArray</span>(data)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 4</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">walk</span>(data)<br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">walk</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">defineReactive</span>(data, key, data[key])<br>    &#125;)<br>  &#125;<br>  <span class="hljs-title function_">observeArray</span>(<span class="hljs-params">data</span>) &#123;<br>    data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">observe</span>(item)<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre>
<ol>
<li>为观测的属性添加 <strong>ob</strong> 属性，它的值等于 this，即当前 Observe 的实例</li>
<li>为数组添加重写的数组方法，比如：push、unshift、splice 等方法，重写目的是在调用这些方法时，进行更新渲染</li>
<li>观测数组内的数据，observe 内部会调用 new Observe，形成递归观测</li>
<li>观测对象数据，defineReactive 为数据定义 get 和 set ，即数据劫持</li>
</ol>
<h3 id="Dep：我会为数据收集依赖"><a href="#Dep：我会为数据收集依赖" class="headerlink" title="Dep：我会为数据收集依赖"></a>Dep：我会为数据收集依赖</h3><pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// 源码位置：/src/core/observer/dep.js</span><br><span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span>&#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = ++id <span class="hljs-comment">// dep 唯一标识</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span> = [] <span class="hljs-comment">// 存储 Watcher</span><br>  &#125;<br>  <span class="hljs-comment">// 1</span><br>  <span class="hljs-title function_">depend</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>.<span class="hljs-title function_">addDep</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br>  <span class="hljs-comment">// 2</span><br>  <span class="hljs-title function_">addSub</span>(<span class="hljs-params">watcher</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">push</span>(watcher)<br>  &#125;<br>  <span class="hljs-comment">// 3</span><br>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">watcher</span> =&gt;</span> watcher.<span class="hljs-title function_">update</span>())<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 4</span><br><span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">null</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pushTarget</span>(<span class="hljs-params">watcher</span>) &#123;<br>  <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = watcher<br>&#125; <br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">popTarget</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">null</span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Dep</span><br></code></pre>

<ol>
<li>数据收集依赖的主要方法，Dep.target 是一个 watcher 实例</li>
<li>添加 watcher 到数组中，也就是添加依赖</li>
<li>属性在变化时会调用 notify 方法，通知每一个依赖进行更新</li>
<li>Dep.target用来记录watcher实例，是全局唯一的，主要作用是为了在收集依赖的过程中找到相应的watcher</li>
</ol>
<p>pushTarget 和 popTarget 这两个方法显而易见是用来设置 Dep.target的。Dep.target 也是一个关键点，这个概念可能初次查看源码会有些难以理解，在后面的流程中，会详细讲解它的作用，需要注意这部分的内容。</p>
<h3 id="Watcher：我会触发视图更新"><a href="#Watcher：我会触发视图更新" class="headerlink" title="Watcher：我会触发视图更新"></a>Watcher：我会触发视图更新</h3><pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// 源码位置：/src/core/observer/watcher.js</span><br><span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, exprOrFn, cb, options</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = ++id  <span class="hljs-comment">// watcher 唯一标识</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span> = vm<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = cb<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = options<br>    <span class="hljs-comment">// 1</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = exprOrFn<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span> = []<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">depIds</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>()<br>  &#125;<br>  <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>()<br>  &#125;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">pushTarget</span>(<span class="hljs-variable language_">this</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getter</span>()<br>    <span class="hljs-title function_">popTarget</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br>  <span class="hljs-comment">// 2</span><br>  <span class="hljs-title function_">addDep</span>(<span class="hljs-params">dep</span>) &#123;<br>    <span class="hljs-comment">// 防止重复添加 dep</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">depIds</span>.<span class="hljs-title function_">has</span>(dep.<span class="hljs-property">id</span>)) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">depIds</span>.<span class="hljs-title function_">add</span>(dep.<span class="hljs-property">id</span>)<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>.<span class="hljs-title function_">push</span>(dep)<br>      dep.<span class="hljs-title function_">addSub</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 3</span><br>  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">queueWatcher</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br>&#125;<br></code></pre>
<ol>
<li>this.getter 存储的是更新视图的函数</li>
<li>watcher 存储 dep，同时 dep 也存储 watcher，进行双向记录</li>
<li>触发更新，queueWatcher 是为了进行异步更新，异步更新会调用 run 方法进行更新页面</li>
</ol>
<h2 id="响应式原理流程"><a href="#响应式原理流程" class="headerlink" title="响应式原理流程"></a>响应式原理流程</h2><p>对于以上这些成员具有的功能，我们都有大概的了解。下面结合它们，来看看这些功能是如何在响应式原理流程中工作的。</p>
<h3 id="数据观测"><a href="#数据观测" class="headerlink" title="数据观测"></a>数据观测</h3><p>数据在初始化时会通过 observe 方法来调用 Observe</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// 源码位置：/src/core/observer/index.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">observe</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-comment">// 1</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isObject</span>(data)) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-keyword">let</span> ob;<br>  <span class="hljs-comment">// 2</span><br>  <span class="hljs-keyword">if</span> (data.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;__ob__&#x27;</span>) &amp;&amp; data.<span class="hljs-property">__ob__</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Observe</span>) &#123;<br>    ob = data.<span class="hljs-property">__ob__</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 3</span><br>    ob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observe</span>(data)<br>  &#125;<br>  <span class="hljs-keyword">return</span> ob<br>&#125;<br></code></pre>

<p>在初始化时，observe 拿到的 data 就是我们在 data 函数内返回的对象。</p>
<ol>
<li>observe 函数只对 object 类型数据进行观测</li>
<li>观测过的数据都会被添加上 <strong>ob</strong> 属性，通过判断该属性是否存在，防止重复观测</li>
<li>创建 Observe 实例，开始处理观测逻辑</li>
</ol>
<h4 id="对象观测"><a href="#对象观测" class="headerlink" title="对象观测"></a>对象观测</h4><p>进入 Observe 内部，由于初始化的数据是一个对象，所以会调用 walk 方法:</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-title function_">walk</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>    <span class="hljs-title function_">defineReactive</span>(data, key, data[key])<br>  &#125;)<br>&#125;<br></code></pre>

<p>defineReactive 方法内部使用 Object.defineProperty 对数据进行劫持，是实现响应式原理最核心的地方。</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">obj, key, value</span>) &#123;<br>  <span class="hljs-comment">// 1</span><br>  <span class="hljs-keyword">let</span> childOb = <span class="hljs-title function_">observe</span>(value)<br>  <span class="hljs-comment">// 2</span><br>  <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>()<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;<br>        <span class="hljs-comment">// 3</span><br>        dep.<span class="hljs-title function_">depend</span>()<br>        <span class="hljs-keyword">if</span> (childOb) &#123;<br>          childOb.<span class="hljs-property">dep</span>.<span class="hljs-title function_">depend</span>()<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> value<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newVal</span>) &#123;<br>      <span class="hljs-keyword">if</span> (newVal === value) &#123;<br>        <span class="hljs-keyword">return</span><br>      &#125;<br>      value = newVal<br>      <span class="hljs-comment">// 4</span><br>      childOb = <span class="hljs-title function_">observe</span>(newVal)<br>      <span class="hljs-comment">// 5</span><br>      dep.<span class="hljs-title function_">notify</span>()<br>      <span class="hljs-keyword">return</span> value<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre>

<ol>
<li>由于值可能是对象类型，这里需要调用 observe 进行递归观测</li>
<li>这里的 dep 就是上面讲到的每一个属性都会有一个 dep，它是作为一个闭包的存在，负责收集依赖和通知更新</li>
<li>在初始化时，Dep.target 是组件的渲染 watcher，这里 dep.depend 收集的依赖就是这个 watcher，childOb.dep.depend 主要是为数组收集依赖</li>
<li>设置的新值可能是对象类型，需要对新值进行观测</li>
<li>值发生改变，dep.notify 通知 watcher 更新，这是我们改变数据后能够实时更新页面的触发点</li>
</ol>
<p>通过 Object.defineProperty 对属性定义后，属性的获取触发 get 回调，属性的设置触发 set 回调，实现响应式更新。</p>
<p>通过上面的逻辑，也能得出为什么 Vue3.0 要使用 Proxy 代替 Object.defineProperty 了。Object.defineProperty 只能对单个属性进行定义，如果属性是对象类型，还需要递归去观测，会很消耗性能。而 Proxy 是代理整个对象，只要属性发生变化就会触发回调。</p>
<h4 id="数组观测"><a href="#数组观测" class="headerlink" title="数组观测"></a>数组观测</h4><p>对于数组类型观测，会调用 observeArray 方法：</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-title function_">observeArray</span>(<span class="hljs-params">data</span>) &#123;<br>  data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    <span class="hljs-title function_">observe</span>(item)<br>  &#125;)<br>&#125;<br></code></pre>

<p>与对象不同，它执行 observe 对数组内的对象类型进行观测，并没有对数组的每一项进行 Object.defineProperty 的定义，也就是说数组内的项是没有 dep 的。</p>
<p>所以，我们通过数组索引对项进行修改时，是不会触发更新的。但可以通过 this.$set 来修改触发更新。那么问题来了，为什么 Vue 要这样设计？</p>
<p>结合实际场景，数组中通常会存放多项数据，比如列表数据。这样观测起来会消耗性能。还有一点原因，一般修改数组元素很少会直接通过索引将整个元素替换掉。例如：</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">list</span>: [<br>                &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>&#125;,<br>                &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Mike&#x27;</span>&#125;<br>            ]<br>        &#125;<br>    &#125;,<br>    <span class="hljs-title function_">cretaed</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 如果想要修改 name 的值，一般是这样使用</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>[<span class="hljs-number">0</span>].<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;JOJO&#x27;</span><br>        <span class="hljs-comment">// 而不是以下这样</span><br>        <span class="hljs-comment">// this.list[0] = &#123;id:1, name: &#x27;JOJO&#x27;&#125;</span><br>        <span class="hljs-comment">// 当然你可以这样更新</span><br>        <span class="hljs-comment">// this.$set(this.list, &#x27;0&#x27;, &#123;id:1, name: &#x27;JOJO&#x27;&#125;)</span><br>    &#125;<br>&#125;<br></code></pre>

<h3 id="数组方法重写"><a href="#数组方法重写" class="headerlink" title="数组方法重写"></a>数组方法重写</h3><p>当数组元素新增或删除，视图会随之更新。这并不是理所当然的，而是 Vue 内部重写了数组的方法，调用这些方法时，数组会更新检测，触发视图更新。这些方法包括：</p>
<ul>
<li>push()</li>
<li>pop()</li>
<li>shift()</li>
<li>unshift()</li>
<li>splice()</li>
<li>sort()</li>
<li>reverse()</li>
</ul>
<p>回到 Observe 的类中，当观测的数据类型为数组时，会调用 protoAugment 方法。</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(data)) &#123;<br>  <span class="hljs-title function_">protoAugment</span>(data, arrayMethods)<br>  <span class="hljs-comment">// 观察数组</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">observeArray</span>(data)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 观察对象</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">walk</span>(data)<br>&#125;<br></code></pre>

<p>这个方法里把数组原型替换为 arrayMethods ，当调用改变数组的方法时，优先使用重写后的方法。</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">protoAugment</span>(<span class="hljs-params">data, arrayMethods</span>) &#123;<br>  data.<span class="hljs-property">__proto__</span> = arrayMethods<br>&#125;<br></code></pre>

<p>接下来看看 arrayMethods 是如何实现的:</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// 源码位置：/src/core/observer/array.js</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-keyword">let</span> arrayProto = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br><span class="hljs-comment">// 2</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> arrayMethods = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(arrayProto)<br><br><span class="hljs-keyword">let</span> methods = [<br>  <span class="hljs-string">&#x27;push&#x27;</span>,<br>  <span class="hljs-string">&#x27;pop&#x27;</span>,<br>  <span class="hljs-string">&#x27;shift&#x27;</span>,<br>  <span class="hljs-string">&#x27;unshift&#x27;</span>,<br>  <span class="hljs-string">&#x27;reverse&#x27;</span>,<br>  <span class="hljs-string">&#x27;sort&#x27;</span>,<br>  <span class="hljs-string">&#x27;splice&#x27;</span><br>]<br><br>methods.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">method</span> =&gt;</span> &#123;<br>  arrayMethods[method] = <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-comment">// 3</span><br>    <span class="hljs-keyword">let</span> res = arrayProto[method].<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)<br>    <span class="hljs-keyword">let</span> ob = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__ob__</span><br>    <span class="hljs-keyword">let</span> inserted = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">switch</span>(method)&#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;push&#x27;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;unshift&#x27;</span>:<br>        inserted = args<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;splice&#x27;</span>:<br>        inserted = args.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 4</span><br>    inserted &amp;&amp; ob.<span class="hljs-title function_">observeArray</span>(inserted)<br>    <span class="hljs-comment">// 5</span><br>    ob.<span class="hljs-property">dep</span>.<span class="hljs-title function_">notify</span>()<br>    <span class="hljs-keyword">return</span> res<br>  &#125;<br>&#125;)<br></code></pre>

<ol>
<li>将数组的原型保存起来，因为重写的数组方法里，还是需要调用原生数组方法的</li>
<li>arrayMethods 是一个对象，用于保存重写的方法，这里使用 Object.create(arrayProto) 创建对象是为了使用者在调用非重写方法时，能够继承使用原生的方法</li>
<li>调用原生方法，存储返回值，用于设置重写函数的返回值</li>
<li>inserted 存储新增的值，若 inserted 存在，对新值进行观测</li>
<li>ob.dep.notify 触发视图更新</li>
</ol>
<h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><p>依赖收集是视图更新的前提，也是响应式原理中至关重要的环节。</p>
<h4 id="伪代码流程"><a href="#伪代码流程" class="headerlink" title="伪代码流程"></a>伪代码流程</h4><p>为了方便理解，这里写一段伪代码，大概了解依赖收集的流程：</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// data 数据</span><br><span class="hljs-keyword">let</span> data = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;joe&#x27;</span><br>&#125;<br><br><span class="hljs-comment">// 渲染watcher</span><br><span class="hljs-keyword">let</span> watcher = &#123;<br>    <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>        dep.<span class="hljs-property">tagret</span> = watcher<br>        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(data.<span class="hljs-property">name</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// dep</span><br><span class="hljs-keyword">let</span> dep = [] <span class="hljs-comment">// 存储依赖 </span><br>dep.<span class="hljs-property">tagret</span> = <span class="hljs-literal">null</span> <span class="hljs-comment">// 记录 watcher</span><br><br><span class="hljs-comment">// 数据劫持</span><br><span class="hljs-keyword">let</span> oldValue = data.<span class="hljs-property">name</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data, <span class="hljs-string">&#x27;name&#x27;</span>, &#123;<br>   <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-comment">// 收集依赖</span><br>       dep.<span class="hljs-title function_">push</span>(dep.<span class="hljs-property">tagret</span>)<br>       <span class="hljs-keyword">return</span> oldValue<br>   &#125;,<br>   <span class="hljs-title function_">set</span>(<span class="hljs-params">newVal</span>)&#123;<br>       oldValue = newVal<br>       dep.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">watcher</span> =&gt;</span> &#123;<br>           watcher.<span class="hljs-title function_">run</span>()<br>       &#125;)<br>       <br>   &#125;<br>&#125;)<br></code></pre>
<p>初始化：</p>
<ol>
<li>首先会对 name 属性定义 get 和 set</li>
<li>然后初始化会执行一次 watcher.run 渲染页面</li>
<li>这时候获取 data.name，触发 get 函数收集依赖。<br>更新：</li>
</ol>
<ul>
<li>修改 data.name，触发 set 函数，调用 run 更新视图。</li>
</ul>
<h4 id="真正流程"><a href="#真正流程" class="headerlink" title="真正流程"></a>真正流程</h4><p>下面来看看真正的依赖收集流程是如何进行的。</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">obj, key, value</span>) &#123;<br>  <span class="hljs-keyword">let</span> childOb = <span class="hljs-title function_">observe</span>(value)<br>  <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>()<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;<br>        dep.<span class="hljs-title function_">depend</span>() <span class="hljs-comment">// 收集依赖</span><br>        <span class="hljs-keyword">if</span> (childOb) &#123;<br>          childOb.<span class="hljs-property">dep</span>.<span class="hljs-title function_">depend</span>()<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> value<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newVal</span>) &#123;<br>      <span class="hljs-keyword">if</span> (newVal === value) &#123;<br>        <span class="hljs-keyword">return</span><br>      &#125;<br>      value = newVal<br>      childOb = <span class="hljs-title function_">observe</span>(newVal)<br>      dep.<span class="hljs-title function_">notify</span>()<br>      <span class="hljs-keyword">return</span> value<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre>

<p>首先初始化数据，调用 defineReactive 函数对数据进行劫持。</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, exprOrFn, cb, options</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = exprOrFn<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>()<br>  &#125;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">pushTarget</span>(<span class="hljs-variable language_">this</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getter</span>()<br>    <span class="hljs-title function_">popTarget</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br>&#125;<br></code></pre>

<p>初始化将 watcher 挂载到 Dep.target，this.getter 开始渲染页面。渲染页面需要对数据取值，触发 get 回调，dep.depend 收集依赖。</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span>&#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id++<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span> = []<br>  &#125;<br>  <span class="hljs-title function_">depend</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>.<span class="hljs-title function_">addDep</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br>&#125;<br></code></pre>

<p>Dep.target 为 watcher，调用 addDep 方法，并传入 dep 实例。</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, exprOrFn, cb, options</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span> = []<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">depIds</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br>  &#125;<br>  <span class="hljs-title function_">addDep</span>(<span class="hljs-params">dep</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">depIds</span>.<span class="hljs-title function_">has</span>(dep.<span class="hljs-property">id</span>)) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">depIds</span>.<span class="hljs-title function_">add</span>(dep.<span class="hljs-property">id</span>)<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>.<span class="hljs-title function_">push</span>(dep)<br>      dep.<span class="hljs-title function_">addSub</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre>

<p>addDep 中添加完 dep 后，调用 dep.addSub 并传入当前 watcher 实例。</p>
<pre class="highlight"><code class="hljs javascript"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span>&#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id++<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span> = []<br>  &#125;<br>  <span class="hljs-title function_">addSub</span>(<span class="hljs-params">watcher</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">push</span>(watcher)<br>  &#125;<br>&#125;<br></code></pre>

<p>将传入的 watcher 收集起来，至此依赖收集流程完毕。</p>
<p>补充一点，通常页面上会绑定很多属性变量，渲染会对属性取值，此时每个属性收集的依赖都是同一个 watcher，即组件的渲染 watcher。</p>
<h3 id="数组的依赖收集"><a href="#数组的依赖收集" class="headerlink" title="数组的依赖收集"></a>数组的依赖收集</h3><pre class="highlight"><code class="hljs javascript">methods.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">method</span> =&gt;</span> &#123;<br>  arrayMethods[method] = <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = arrayProto[method].<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)<br>    <span class="hljs-keyword">let</span> ob = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__ob__</span><br>    <span class="hljs-keyword">let</span> inserted = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">switch</span>(method)&#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;push&#x27;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;unshift&#x27;</span>:<br>        inserted = args<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;splice&#x27;</span>:<br>        inserted = args.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 对新增的值观测</span><br>    inserted &amp;&amp; ob.<span class="hljs-title function_">observeArray</span>(inserted)<br>    <span class="hljs-comment">// 更新视图</span><br>    ob.<span class="hljs-property">dep</span>.<span class="hljs-title function_">notify</span>()<br>    <span class="hljs-keyword">return</span> res<br>  &#125;<br>&#125;)<br></code></pre>

<p>还记得重写的方法里，会调用 ob.dep.notify 更新视图，<strong>ob</strong> 是我们在 Observe 为观测数据定义的标识，值为 Observe 实例。那么 ob.dep 的依赖是在哪里收集的？</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">obj, key, value</span>) &#123;<br>  <span class="hljs-comment">// 1</span><br>  <span class="hljs-keyword">let</span> childOb = <span class="hljs-title function_">observe</span>(value)<br>  <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>()<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;<br>        dep.<span class="hljs-title function_">depend</span>()<br>        <span class="hljs-comment">// 2</span><br>        <span class="hljs-keyword">if</span> (childOb) &#123;<br>          childOb.<span class="hljs-property">dep</span>.<span class="hljs-title function_">depend</span>()<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> value<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newVal</span>) &#123;<br>      <span class="hljs-keyword">if</span> (newVal === value) &#123;<br>        <span class="hljs-keyword">return</span><br>      &#125;<br>      value = newVal<br>      childOb = <span class="hljs-title function_">observe</span>(newVal)<br>      dep.<span class="hljs-title function_">notify</span>()<br>      <span class="hljs-keyword">return</span> value<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre>

<ol>
<li>observe 函数返回值为 Observe 实例</li>
<li>childOb.dep.depend 执行，为 Observe 实例的 dep 添加依赖<br>所以在数组更新时，ob.dep 内已经收集到依赖了。</li>
</ol>
<h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p>下面捋一遍初始化流程和更新流程，如果你是初次看源码，不知道从哪里看起，也可以参照以下的顺序。由于源码实现比较多，下面展示的源码会稍微删减一些代码</p>
<h3 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h3><h4 id="入口文件："><a href="#入口文件：" class="headerlink" title="入口文件："></a>入口文件：</h4><pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// 源码位置：/src/core/instance/index.js</span><br><span class="hljs-keyword">import</span> &#123; initMixin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./init&#x27;</span><br><span class="hljs-keyword">import</span> &#123; stateMixin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./state&#x27;</span><br><span class="hljs-keyword">import</span> &#123; renderMixin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./render&#x27;</span><br><span class="hljs-keyword">import</span> &#123; eventsMixin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./events&#x27;</span><br><span class="hljs-keyword">import</span> &#123; lifecycleMixin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./lifecycle&#x27;</span><br><span class="hljs-keyword">import</span> &#123; warn &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../util/index&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Vue</span> (options) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_init</span>(options)<br>&#125;<br><br><span class="hljs-title function_">initMixin</span>(<span class="hljs-title class_">Vue</span>)<br><span class="hljs-title function_">stateMixin</span>(<span class="hljs-title class_">Vue</span>)<br><span class="hljs-title function_">eventsMixin</span>(<span class="hljs-title class_">Vue</span>)<br><span class="hljs-title function_">lifecycleMixin</span>(<span class="hljs-title class_">Vue</span>)<br><span class="hljs-title function_">renderMixin</span>(<span class="hljs-title class_">Vue</span>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Vue</span><br></code></pre>

<h4 id="init："><a href="#init：" class="headerlink" title="_init："></a>_init：</h4><pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// 源码位置：/src/core/instance/init.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initMixin</span> (<span class="hljs-title class_">Vue</span>: <span class="hljs-title class_">Class</span>&lt;<span class="hljs-title class_">Component</span>&gt;) &#123;<br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_init</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">options?: <span class="hljs-built_in">Object</span></span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span> = <span class="hljs-variable language_">this</span><br>    <span class="hljs-comment">// a uid</span><br>    vm.<span class="hljs-property">_uid</span> = uid++<br><br>    <span class="hljs-comment">// merge options</span><br>    <span class="hljs-keyword">if</span> (options &amp;&amp; options.<span class="hljs-property">_isComponent</span>) &#123;<br>      <span class="hljs-comment">// optimize internal component instantiation</span><br>      <span class="hljs-comment">// since dynamic options merging is pretty slow, and none of the</span><br>      <span class="hljs-comment">// internal component options needs special treatment.</span><br>      <span class="hljs-title function_">initInternalComponent</span>(vm, options)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// mergeOptions 对 mixin 选项和 new Vue 传入的 options 选项进行合并</span><br>      vm.<span class="hljs-property">$options</span> = <span class="hljs-title function_">mergeOptions</span>(<br>        <span class="hljs-title function_">resolveConstructorOptions</span>(vm.<span class="hljs-property">constructor</span>),<br>        options || &#123;&#125;,<br>        vm<br>      )<br>    &#125;<br><br>    <span class="hljs-comment">// expose real self</span><br>    vm.<span class="hljs-property">_self</span> = vm<br>    <span class="hljs-title function_">initLifecycle</span>(vm)<br>    <span class="hljs-title function_">initEvents</span>(vm)<br>    <span class="hljs-title function_">initRender</span>(vm)<br>    <span class="hljs-title function_">callHook</span>(vm, <span class="hljs-string">&#x27;beforeCreate&#x27;</span>)<br>    <span class="hljs-title function_">initInjections</span>(vm) <span class="hljs-comment">// resolve injections before data/props</span><br>    <span class="hljs-comment">// 初始化数据</span><br>    <span class="hljs-title function_">initState</span>(vm)<br>    <span class="hljs-title function_">initProvide</span>(vm) <span class="hljs-comment">// resolve provide after data/props</span><br>    <span class="hljs-title function_">callHook</span>(vm, <span class="hljs-string">&#x27;created&#x27;</span>)<br><br>    <span class="hljs-keyword">if</span> (vm.<span class="hljs-property">$options</span>.<span class="hljs-property">el</span>) &#123;<br>      <span class="hljs-comment">// 初始化渲染页面 挂载组件</span><br>      vm.$mount(vm.<span class="hljs-property">$options</span>.<span class="hljs-property">el</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre>
<p>上面主要关注两个函数，initState 初始化数据，vm.$mount(vm.$options.el) 初始化渲染页面。</p>
<h4 id="initState："><a href="#initState：" class="headerlink" title="initState："></a>initState：</h4><pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// 源码位置：/src/core/instance/state.js </span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initState</span> (<span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span>) &#123;<br>  vm.<span class="hljs-property">_watchers</span> = []<br>  <span class="hljs-keyword">const</span> opts = vm.<span class="hljs-property">$options</span><br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">props</span>) <span class="hljs-title function_">initProps</span>(vm, opts.<span class="hljs-property">props</span>)<br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">methods</span>) <span class="hljs-title function_">initMethods</span>(vm, opts.<span class="hljs-property">methods</span>)<br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">data</span>) &#123;<br>    <span class="hljs-comment">// data 初始化</span><br>    <span class="hljs-title function_">initData</span>(vm)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">observe</span>(vm.<span class="hljs-property">_data</span> = &#123;&#125;, <span class="hljs-literal">true</span> <span class="hljs-comment">/* asRootData */</span>)<br>  &#125;<br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">computed</span>) <span class="hljs-title function_">initComputed</span>(vm, opts.<span class="hljs-property">computed</span>)<br>  <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">watch</span> &amp;&amp; opts.<span class="hljs-property">watch</span> !== nativeWatch) &#123;<br>    <span class="hljs-title function_">initWatch</span>(vm, opts.<span class="hljs-property">watch</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initData</span> (<span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span>) &#123;<br>  <span class="hljs-keyword">let</span> data = vm.<span class="hljs-property">$options</span>.<span class="hljs-property">data</span><br>  <span class="hljs-comment">// data 为函数时，执行 data 函数，取出返回值</span><br>  data = vm.<span class="hljs-property">_data</span> = <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&#x27;function&#x27;</span><br>    ? <span class="hljs-title function_">getData</span>(data, vm)<br>    : data || &#123;&#125;<br>  <span class="hljs-comment">// proxy data on instance</span><br>  <span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data)<br>  <span class="hljs-keyword">const</span> props = vm.<span class="hljs-property">$options</span>.<span class="hljs-property">props</span><br>  <span class="hljs-keyword">const</span> methods = vm.<span class="hljs-property">$options</span>.<span class="hljs-property">methods</span><br>  <span class="hljs-keyword">let</span> i = keys.<span class="hljs-property">length</span><br>  <span class="hljs-keyword">while</span> (i--) &#123;<br>    <span class="hljs-keyword">const</span> key = keys[i]<br>    <span class="hljs-keyword">if</span> (props &amp;&amp; <span class="hljs-title function_">hasOwn</span>(props, key)) &#123;<br>      process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; <span class="hljs-title function_">warn</span>(<br>        <span class="hljs-string">`The data property &quot;<span class="hljs-subst">$&#123;key&#125;</span>&quot; is already declared as a prop. `</span> +<br>        <span class="hljs-string">`Use prop default value instead.`</span>,<br>        vm<br>      )<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isReserved</span>(key)) &#123;<br>      <span class="hljs-title function_">proxy</span>(vm, <span class="hljs-string">`_data`</span>, key)<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// observe data</span><br>  <span class="hljs-comment">// 这里就开始走观测数据的逻辑了</span><br>  <span class="hljs-title function_">observe</span>(data, <span class="hljs-literal">true</span> <span class="hljs-comment">/* asRootData */</span>)<br>&#125;<br></code></pre>

<p>observe 内部流程在上面已经讲过，这里再简单过一遍：</p>
<ol>
<li>new Observe 观测数据</li>
<li>defineReactive 对数据进行劫持</li>
</ol>
<p>initState 逻辑执行完毕，回到开头，接下来执行 <code>vm.$mount(vm.$options.el)</code> 渲染页面：</p>
<h4 id="mount"><a href="#mount" class="headerlink" title="$mount:"></a>$mount:</h4><pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// 源码位置：/src/platforms/web/runtime/index.js </span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$mount</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span><br><span class="hljs-params">  el?: string | Element,</span><br><span class="hljs-params">  hydrating?: boolean</span><br><span class="hljs-params"></span>): <span class="hljs-title class_">Component</span> &#123;<br>  el = el &amp;&amp; inBrowser ? <span class="hljs-title function_">query</span>(el) : <span class="hljs-literal">undefined</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountComponent</span>(<span class="hljs-variable language_">this</span>, el, hydrating)<br>&#125;<br></code></pre>

<h4 id="mountComponent"><a href="#mountComponent" class="headerlink" title="mountComponent:"></a>mountComponent:</h4><pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// 源码位置：/src/core/instance/lifecycle.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountComponent</span> (<br>  <span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span>,<br>  <span class="hljs-attr">el</span>: ?<span class="hljs-title class_">Element</span>,<br>  hydrating?: boolean<br>): <span class="hljs-title class_">Component</span> &#123;<br>  vm.<span class="hljs-property">$el</span> = el<br>  <span class="hljs-title function_">callHook</span>(vm, <span class="hljs-string">&#x27;beforeMount&#x27;</span>)<br><br>  <span class="hljs-keyword">let</span> updateComponent<br>  <span class="hljs-comment">/* istanbul ignore if */</span><br>  <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="hljs-property">performance</span> &amp;&amp; mark) &#123;<br>    updateComponent = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> name = vm.<span class="hljs-property">_name</span><br>      <span class="hljs-keyword">const</span> id = vm.<span class="hljs-property">_uid</span><br>      <span class="hljs-keyword">const</span> startTag = <span class="hljs-string">`vue-perf-start:<span class="hljs-subst">$&#123;id&#125;</span>`</span><br>      <span class="hljs-keyword">const</span> endTag = <span class="hljs-string">`vue-perf-end:<span class="hljs-subst">$&#123;id&#125;</span>`</span><br><br>      <span class="hljs-title function_">mark</span>(startTag)<br>      <span class="hljs-keyword">const</span> vnode = vm.<span class="hljs-title function_">_render</span>()<br>      <span class="hljs-title function_">mark</span>(endTag)<br>      <span class="hljs-title function_">measure</span>(<span class="hljs-string">`vue <span class="hljs-subst">$&#123;name&#125;</span> render`</span>, startTag, endTag)<br><br>      <span class="hljs-title function_">mark</span>(startTag)<br>      vm.<span class="hljs-title function_">_update</span>(vnode, hydrating)<br>      <span class="hljs-title function_">mark</span>(endTag)<br>      <span class="hljs-title function_">measure</span>(<span class="hljs-string">`vue <span class="hljs-subst">$&#123;name&#125;</span> patch`</span>, startTag, endTag)<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 数据改变时  会调用此方法</span><br>    updateComponent = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// vm._render() 返回 vnode，这里面会就对 data 数据进行取值</span><br>      <span class="hljs-comment">// vm._update 将 vnode 转为真实dom，渲染到页面上</span><br>      vm.<span class="hljs-title function_">_update</span>(vm.<span class="hljs-title function_">_render</span>(), hydrating)<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 执行 Watcher，这个就是上面所说的渲染wacther </span><br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, updateComponent, noop, &#123;<br>    before () &#123;<br>      <span class="hljs-keyword">if</span> (vm.<span class="hljs-property">_isMounted</span> &amp;&amp; !vm.<span class="hljs-property">_isDestroyed</span>) &#123;<br>        <span class="hljs-title function_">callHook</span>(vm, <span class="hljs-string">&#x27;beforeUpdate&#x27;</span>)<br>      &#125;<br>    &#125;<br>  &#125;, <span class="hljs-literal">true</span> <span class="hljs-comment">/* isRenderWatcher */</span>)<br>  hydrating = <span class="hljs-literal">false</span><br><br>  <span class="hljs-comment">// manually mounted instance, call mounted on self</span><br>  <span class="hljs-comment">// mounted is called for render-created child components in its inserted hook</span><br>  <span class="hljs-keyword">if</span> (vm.<span class="hljs-property">$vnode</span> == <span class="hljs-literal">null</span>) &#123;<br>    vm.<span class="hljs-property">_isMounted</span> = <span class="hljs-literal">true</span><br>    <span class="hljs-title function_">callHook</span>(vm, <span class="hljs-string">&#x27;mounted&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> vm<br>&#125;<br></code></pre>

<h4 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher:"></a>Watcher:</h4><pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// 源码位置：/src/core/observer/watcher.js </span><br><span class="hljs-keyword">let</span> uid = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, exprOrFn, cb, options</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = ++id<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span> = vm<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = cb<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = options<br>    <span class="hljs-comment">// exprOrFn 就是上面传入的 updateComponent</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = exprOrFn<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span> = []<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">depIds</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>()<br>  &#125;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 1. pushTarget 将当前 watcher 记录到 Dep.target，Dep.target 是全局唯一的</span><br>    <span class="hljs-title function_">pushTarget</span>(<span class="hljs-variable language_">this</span>)<br>    <span class="hljs-keyword">let</span> value<br>    <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span><br>    <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 2. 调用 this.getter 相当于会执行 vm._render 函数，对实例上的属性取值，</span><br>    <span class="hljs-comment">//由此触发 Object.defineProperty 的 get 方法，在 get 方法内进行依赖收集（dep.depend），这里依赖收集就需要用到 Dep.target</span><br>      value = <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span>.<span class="hljs-title function_">call</span>(vm, vm)<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>) &#123;<br>        <span class="hljs-title function_">handleError</span>(e, vm, <span class="hljs-string">`getter for watcher &quot;<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.expression&#125;</span>&quot;`</span>)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> e<br>      &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-comment">// &quot;touch&quot; every property so they are all tracked as</span><br>      <span class="hljs-comment">// dependencies for deep watching</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">deep</span>) &#123;<br>        <span class="hljs-title function_">traverse</span>(value)<br>      &#125;<br>      <span class="hljs-comment">// 3. popTarget 将 Dep.target 置空</span><br>      <span class="hljs-title function_">popTarget</span>()<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cleanupDeps</span>()<br>    &#125;<br>    <span class="hljs-keyword">return</span> value<br>  &#125;<br>&#125;<br></code></pre>

<p>至此初始化流程完毕，初始化流程的主要工作是数据劫持、渲染页面和收集依赖。</p>
<h3 id="更新流程"><a href="#更新流程" class="headerlink" title="更新流程"></a>更新流程</h3><p>数据发生变化，触发 set ，执行 dep.notify</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// 源码位置：/src/core/observer/dep.js </span><br><span class="hljs-keyword">let</span> uid = <span class="hljs-number">0</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A dep is an observable that can have multiple</span><br><span class="hljs-comment"> * directives subscribing to it.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-attr">target</span>: ?<span class="hljs-title class_">Watcher</span>;<br>  <span class="hljs-attr">id</span>: number;<br>  <span class="hljs-attr">subs</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Watcher</span>&gt;;<br><br>  <span class="hljs-title function_">constructor</span> () &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = uid++<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span> = []<br>  &#125;<br><br>  addSub (<span class="hljs-attr">sub</span>: <span class="hljs-title class_">Watcher</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">push</span>(sub)<br>  &#125;<br><br>  removeSub (<span class="hljs-attr">sub</span>: <span class="hljs-title class_">Watcher</span>) &#123;<br>    <span class="hljs-title function_">remove</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>, sub)<br>  &#125;<br><br>  depend () &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;<br>      <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>.<span class="hljs-title function_">addDep</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;<br>  &#125;<br><br>  notify () &#123;<br>    <span class="hljs-comment">// stabilize the subscriber list first</span><br>    <span class="hljs-keyword">const</span> subs = <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">slice</span>()<br>    <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; !config.<span class="hljs-property">async</span>) &#123;<br>      <span class="hljs-comment">// subs aren&#x27;t sorted in scheduler if not running async</span><br>      <span class="hljs-comment">// we need to sort them now to make sure they fire in correct</span><br>      <span class="hljs-comment">// order</span><br>      subs.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.<span class="hljs-property">id</span> - b.<span class="hljs-property">id</span>)<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = subs.<span class="hljs-property">length</span>; i &lt; l; i++) &#123;<br>      <span class="hljs-comment">// 执行 watcher 的 update 方法</span><br>      subs[i].<span class="hljs-title function_">update</span>()<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre>

<h4 id="wathcer-update："><a href="#wathcer-update：" class="headerlink" title="wathcer.update："></a>wathcer.update：</h4><pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// 源码位置：/src/core/observer/watcher.js </span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Subscriber interface.</span><br><span class="hljs-comment"> * Will be called when a dependency changes.</span><br><span class="hljs-comment"> */</span><br>update () &#123;<br>  <span class="hljs-comment">/* istanbul ignore else */</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span>) &#123;  <span class="hljs-comment">// 计算属性更新</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dirty</span> = <span class="hljs-literal">true</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">sync</span>) &#123;  <span class="hljs-comment">// 同步更新</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">run</span>()<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 一般的数据都会进行异步更新</span><br>    <span class="hljs-title function_">queueWatcher</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br>&#125;<br></code></pre>

<h4 id="queueWatcher"><a href="#queueWatcher" class="headerlink" title="queueWatcher:"></a>queueWatcher:</h4><pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// 源码位置：/src/core/observer/scheduler.js</span><br><br><span class="hljs-comment">// 用于存储 watcher</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">queue</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Watcher</span>&gt; = []<br><span class="hljs-comment">// 用于 watcher 去重</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">has</span>: &#123; [<span class="hljs-attr">key</span>: number]: ?<span class="hljs-literal">true</span> &#125; = &#123;&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Flush both queues and run the watchers.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flushSchedulerQueue</span> () &#123;<br>  <span class="hljs-keyword">let</span> watcher, id<br><br>  <span class="hljs-comment">// 对 watcher 排序</span><br>  queue.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.<span class="hljs-property">id</span> - b.<span class="hljs-property">id</span>)<br><br>  <span class="hljs-comment">// do not cache length because more watchers might be pushed</span><br>  <span class="hljs-comment">// as we run existing watchers</span><br>  <span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; queue.<span class="hljs-property">length</span>; index++) &#123;<br>    watcher = queue[index]<br>    id = watcher.<span class="hljs-property">id</span><br>    has[id] = <span class="hljs-literal">null</span><br>    <span class="hljs-comment">// run方法更新视图</span><br>    watcher.<span class="hljs-title function_">run</span>()<br>  &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Push a watcher into the watcher queue.</span><br><span class="hljs-comment"> * Jobs with duplicate IDs will be skipped unless it&#x27;s</span><br><span class="hljs-comment"> * pushed when the queue is being flushed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">queueWatcher</span> (<span class="hljs-attr">watcher</span>: <span class="hljs-title class_">Watcher</span>) &#123;<br>  <span class="hljs-keyword">const</span> id = watcher.<span class="hljs-property">id</span><br>  <span class="hljs-keyword">if</span> (has[id] == <span class="hljs-literal">null</span>) &#123;<br>    has[id] = <span class="hljs-literal">true</span><br>    <span class="hljs-comment">// watcher 加入数组</span><br>    queue.<span class="hljs-title function_">push</span>(watcher)<br>    <span class="hljs-comment">// 异步更新</span><br>    <span class="hljs-title function_">nextTick</span>(flushSchedulerQueue)<br>  &#125;<br>&#125;<br></code></pre>

<h4 id="nextTick："><a href="#nextTick：" class="headerlink" title="nextTick："></a>nextTick：</h4><pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// 源码位置：/src/core/util/next-tick.js</span><br><br><span class="hljs-keyword">const</span> callbacks = []<br><span class="hljs-keyword">let</span> pending = <span class="hljs-literal">false</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flushCallbacks</span> () &#123;<br>  pending = <span class="hljs-literal">false</span><br>  <span class="hljs-keyword">const</span> copies = callbacks.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>)<br>  callbacks.<span class="hljs-property">length</span> = <span class="hljs-number">0</span><br>  <span class="hljs-comment">// 遍历回调函数执行</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; copies.<span class="hljs-property">length</span>; i++) &#123;<br>    copies[i]()<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> timerFunc<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Promise</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="hljs-title function_">isNative</span>(<span class="hljs-title class_">Promise</span>)) &#123;<br>  <span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()<br>  timerFunc = <span class="hljs-function">() =&gt;</span> &#123;<br>    p.<span class="hljs-title function_">then</span>(flushCallbacks)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">nextTick</span> (cb?: <span class="hljs-title class_">Function</span>, ctx?: <span class="hljs-title class_">Object</span>) &#123;<br>  <span class="hljs-keyword">let</span> _resolve<br>  <span class="hljs-comment">// 将回调函数加入数组</span><br>  callbacks.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (cb) &#123;<br>      cb.<span class="hljs-title function_">call</span>(ctx)<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">if</span> (!pending) &#123;<br>    pending = <span class="hljs-literal">true</span><br>    <span class="hljs-comment">// 遍历回调函数执行</span><br>    <span class="hljs-title function_">timerFunc</span>()<br>  &#125;<br>  <span class="hljs-comment">// $flow-disable-line</span><br>  <span class="hljs-keyword">if</span> (!cb &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Promise</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>      _resolve = resolve<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre>

<p>这一步是为了使用微任务将回调函数异步执行，也就是上面的p.then。最终，会调用 watcher.run 更新页面。</p>
<p>至此更新流程完毕。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>如果没有接触过源码的同学，我相信看完可能还是会有点懵的，这很正常。建议对照源码再自己多看几遍就能知道流程了。对于有基础的同学就当做是复习了。</p>
<p>想要变强，学会看源码是必经之路。在这过程中，不仅能学习框架的设计思想，还能培养自己的逻辑思维。万事开头难，迟早都要迈出这一步，不如就从今天开始。</p>
<p>简化后的代码我已放在 <a target="_blank" rel="noopener" href="https://github.com/ChanWahFung/vue-source-demo">github</a>，有需要的可以看看。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000021039085">手摸手带你理解Vue响应式原理</a></p>

  </div>
  <div>
    
  </div>
</article>
<div class="nav">
  
    <div class="nav-item-prev">
      <a 
        href="/2022/09/30/22092802/" 
        class="nav-link">
        <i class="iconfont icon-left nav-prev-icon"></i>
        <div>
          <div class="nav-label">上一篇</div>
          
            <div class="nav-title">v-model源码解析(超详细) </div>
          
        </div>
      </a>
    </div>
  
  
    <div class="nav-item-next">
      <a 
        href="/2022/09/30/22092804/" 
        class="nav-link">
        <div>
          <div class="nav-label">下一篇</div>
          
            <div class="nav-title">虚拟内存 &amp; I/O &amp; 零拷贝总结 </div>
          
        </div>
        <i class="iconfont icon-right nav-next-icon"></i>
      </a>
    </div>
  
</div>

<div 
  class="card card-content toc-card" 
  id="mobiletoc">
  <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>目录
</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%88%90%E5%91%98"><span class="toc-text">主要成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Observe%EF%BC%9A%E6%88%91%E4%BC%9A%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E8%A7%82%E6%B5%8B"><span class="toc-text">Observe：我会对数据进行观测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dep%EF%BC%9A%E6%88%91%E4%BC%9A%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E4%BE%9D%E8%B5%96"><span class="toc-text">Dep：我会为数据收集依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Watcher%EF%BC%9A%E6%88%91%E4%BC%9A%E8%A7%A6%E5%8F%91%E8%A7%86%E5%9B%BE%E6%9B%B4%E6%96%B0"><span class="toc-text">Watcher：我会触发视图更新</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-text">响应式原理流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A7%82%E6%B5%8B"><span class="toc-text">数据观测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%A7%82%E6%B5%8B"><span class="toc-text">对象观测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%A7%82%E6%B5%8B"><span class="toc-text">数组观测</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-text">数组方法重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86"><span class="toc-text">依赖收集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B"><span class="toc-text">伪代码流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9C%9F%E6%AD%A3%E6%B5%81%E7%A8%8B"><span class="toc-text">真正流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86"><span class="toc-text">数组的依赖收集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-text">整体流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-text">初始化流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6%EF%BC%9A"><span class="toc-text">入口文件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#init%EF%BC%9A"><span class="toc-text">_init：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#initState%EF%BC%9A"><span class="toc-text">initState：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mount"><span class="toc-text">$mount:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mountComponent"><span class="toc-text">mountComponent:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Watcher"><span class="toc-text">Watcher:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B"><span class="toc-text">更新流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#wathcer-update%EF%BC%9A"><span class="toc-text">wathcer.update：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queueWatcher"><span class="toc-text">queueWatcher:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nextTick%EF%BC%9A"><span class="toc-text">nextTick：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E"><span class="toc-text">写在最后</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-text">参考链接</span></a></li></ol>
</div>

            </main>
            <aside class="right-column">
              <div class="sticky-widescreen">
  
  
    <article class="card card-content toc-card">
      <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>目录
</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%88%90%E5%91%98"><span class="toc-text">主要成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Observe%EF%BC%9A%E6%88%91%E4%BC%9A%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E8%A7%82%E6%B5%8B"><span class="toc-text">Observe：我会对数据进行观测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dep%EF%BC%9A%E6%88%91%E4%BC%9A%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E4%BE%9D%E8%B5%96"><span class="toc-text">Dep：我会为数据收集依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Watcher%EF%BC%9A%E6%88%91%E4%BC%9A%E8%A7%A6%E5%8F%91%E8%A7%86%E5%9B%BE%E6%9B%B4%E6%96%B0"><span class="toc-text">Watcher：我会触发视图更新</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-text">响应式原理流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A7%82%E6%B5%8B"><span class="toc-text">数据观测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%A7%82%E6%B5%8B"><span class="toc-text">对象观测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%A7%82%E6%B5%8B"><span class="toc-text">数组观测</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-text">数组方法重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86"><span class="toc-text">依赖收集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B"><span class="toc-text">伪代码流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9C%9F%E6%AD%A3%E6%B5%81%E7%A8%8B"><span class="toc-text">真正流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86"><span class="toc-text">数组的依赖收集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-text">整体流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-text">初始化流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6%EF%BC%9A"><span class="toc-text">入口文件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#init%EF%BC%9A"><span class="toc-text">_init：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#initState%EF%BC%9A"><span class="toc-text">initState：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mount"><span class="toc-text">$mount:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mountComponent"><span class="toc-text">mountComponent:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Watcher"><span class="toc-text">Watcher:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B"><span class="toc-text">更新流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#wathcer-update%EF%BC%9A"><span class="toc-text">wathcer.update：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queueWatcher"><span class="toc-text">queueWatcher:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nextTick%EF%BC%9A"><span class="toc-text">nextTick：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E"><span class="toc-text">写在最后</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-text">参考链接</span></a></li></ol>
    </article>
  
  
  <article class="card card-content">
    <div class="recent-posts-card">
  <div class="recent-posts-header">
    <i 
      class="iconfont icon-wenzhang_huaban" 
      style="padding-right: 2px;">
    </i>最近文章
  </div>
  <div class="recent-posts-list">
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-11-25</div>
        <a href="/2022/11/25/22112501/"><div class="recent-posts-item-content">从0创建一个vue项目</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-11-24</div>
        <a href="/2022/11/24/22112401/"><div class="recent-posts-item-content">原神机器人使用帮助</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-11-22</div>
        <a href="/2022/11/22/22112202/"><div class="recent-posts-item-content">原生js实现图片懒加载（lazyLoad）</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-11-22</div>
        <a href="/2022/11/22/22112203/"><div class="recent-posts-item-content">Windows的Flask怎样让局域网的同事访问到</div></a>
      </div>
    
  </div>
</div>
  </article>
  
  
  <article class="card card-content">
    <h1 style="padding-bottom: 12px;">关注嘉然！顿顿解馋！</h1>
    <img src="https://api2.mubu.com/v3/document_image/2697c6ae-10ee-41a3-9099-304bdb252d31-3807603.jpg">
  </article>
</div>
            </aside>
          </div>
        </div>
      </div>
    </div>
     
    <footer class="footer">
  <div class="footer-container">
    <div>
      <div class="footer-dsc">
        <span>
          Copyright ©
          
            2020
          
          
                - 
                2022
          
        </span>
        &nbsp;
        <a 
          href="/" 
          class="footer-link">
          霜序廿的个人网站
        </a>
      </div>
    </div>

    
      <div class="footer-dsc">
        
          Powered by
          <a 
            href="https://hexo.io/" 
            class="footer-link" 
            target="_blank" 
            rel="nofollow noopener noreferrer">
            &nbsp;Hexo
          </a>
        
        
          <span>&nbsp;|&nbsp;</span>
        
        
          Theme -
          <a 
            href="https://github.com/theme-kaze" 
            class="footer-link" 
            target="_blank"
            rel="nofollow noopener noreferrer">
            &nbsp;Kaze
          </a>
        
      </div>
    
    
    
    
</footer>
 
    
  <a 
    role="button" 
    id="scrollbutton" 
    class="basebutton" 
    aria-label="回到顶部">
    <i class="iconfont icon-arrowleft button-icon"></i>
  </a>

<a 
  role="button" 
  id="menubutton"
  aria-label="menu button"
  class="basebutton">
  <i class="iconfont icon-menu button-icon"></i>
</a>
<a 
  role="button" 
  id="popbutton" 
  class="basebutton" 
  aria-label="控制中心">
  <i class="iconfont icon-expand button-icon"></i>
</a>
<a 
  role="button" 
  id="darkbutton" 
  class="basebutton darkwidget" 
  aria-label="夜色模式">
  <i class="iconfont icon-weather button-icon"></i>
</a>
<a 
  role="button" 
  id="searchbutton" 
  class="basebutton searchwidget" 
  aria-label="搜索">
  <i class="iconfont icon-search button-icon"></i>
</a> 
     
     
     
      <script>
  var addImgLayout = function () {
    var img = document.querySelectorAll('.post-content img')
    var i
    for (i = 0; i < img.length; i++) {
      var wrapper = document.createElement('a')
      wrapper.setAttribute('href', img[i].getAttribute('data-src'))
      wrapper.setAttribute('aria-label', 'illustration')
      wrapper.style.cssText =
        'width: 100%; display: flex; justify-content: center;'
      if (img[i].alt) wrapper.dataset.caption = img[i].alt
      wrapper.dataset.nolink = true
      img[i].before(wrapper)
      wrapper.append(img[i])
      var divWrap = document.createElement('div')
      divWrap.classList.add('gallery')
      wrapper.before(divWrap)
      divWrap.append(wrapper)
    }
    baguetteBox.run('.gallery')
  }
</script>
<script>
  loadScript(
    "/js/lib/lightbox/baguetteBox.min.js",
    addImgLayout
  )
</script>
 
     
     
    <script src="/js/main.js"></script> 
     
    
      <script>
        var addLazyload = function () {
          var observer = lozad('.lozad', {
            load: function (el) {
              el.srcset = el.getAttribute('data-src')
            },
            loaded: function (el) {
              el.classList.add('loaded')
            },
          })
          observer.observe()
        }
      </script>
      <script>
        loadScript('/js/lib/lozad.min.js', addLazyload)
      </script>
    
    <script src="//instant.page/5.1.0" type="module"
      integrity="sha384-by67kQnR+pyfy8yWP4kPO12fHKRLHZPfEsiSXR8u2IKcTdxD805MGUXBzVPnkLHw"></script>
    
    
  </body>
</html>
